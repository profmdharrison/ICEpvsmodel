%% TCCs associated with theory system_th
%% This file was automatically generated by PVS, please **do not modify** by hand.
system_th_TCCS: THEORY BEGIN

	% Assuming TCC generated (at line 9, column 13) for
	% patient_th[maxrate, maxinfuse, maxtime]
	% generated from assumption patient_th.maxinfuseLEQmaxtime
	  % proved
	IMP_patient_th_TCC1: OBLIGATION
	maxinfuse <= maxtime
	
	% Disjointness TCC generated (at line 118, column 17) for
	% COND is`disp_focus = no_focus -> no_focus,
	%      is`disp_focus = top_focus -> no_focus,
	%      is`disp_focus = patient_focus -> top_focus,
	%      is`disp_focus = device_focus -> patient_focus
	% ENDCOND
	  % untried
	i_up_display_TCC1: OBLIGATION
	FORALL (xs: interface_st, is: i_state[maxrate, maxinfuse, maxtime]):
	    is = xs`ss`coord_st IMPLIES
	          (NOT (is`disp_focus = no_focus AND is`disp_focus = patient_focus))
	      AND (NOT (is`disp_focus = no_focus AND is`disp_focus = device_focus))
	      AND (NOT (is`disp_focus = top_focus AND is`disp_focus = patient_focus))
	      AND (NOT (is`disp_focus = top_focus AND is`disp_focus = device_focus))
	      AND NOT (is`disp_focus = patient_focus AND is`disp_focus = device_focus)
	
	% Coverage TCC generated (at line 118, column 17) for
	% COND is`disp_focus = no_focus -> no_focus,
	%      is`disp_focus = top_focus -> no_focus,
	%      is`disp_focus = patient_focus -> top_focus,
	%      is`disp_focus = device_focus -> patient_focus
	% ENDCOND
	  % untried
	i_up_display_TCC2: OBLIGATION
	FORALL (xs: interface_st, is: i_state[maxrate, maxinfuse, maxtime]):
	    is = xs`ss`coord_st IMPLIES
	     is`disp_focus = no_focus OR
	      is`disp_focus = top_focus OR
	       is`disp_focus = patient_focus OR is`disp_focus = device_focus
	
	% Disjointness TCC generated (at line 134, column 16) for
	% COND is`disp_focus = no_focus -> top_focus,
	%      is`disp_focus = top_focus -> patient_focus,
	%      is`disp_focus = patient_focus -> device_focus,
	%      is`disp_focus = device_focus -> no_focus
	% ENDCOND
	  % untried
	i_down_display_TCC1: OBLIGATION
	FORALL (xs: interface_st, is: i_state[maxrate, maxinfuse, maxtime]):
	    is = xs`ss`coord_st IMPLIES
	          (NOT (is`disp_focus = no_focus AND is`disp_focus = top_focus))
	      AND (NOT (is`disp_focus = no_focus AND is`disp_focus = patient_focus))
	      AND (NOT (is`disp_focus = no_focus AND is`disp_focus = device_focus))
	      AND (NOT (is`disp_focus = top_focus AND is`disp_focus = patient_focus))
	      AND (NOT (is`disp_focus = top_focus AND is`disp_focus = device_focus))
	      AND NOT (is`disp_focus = patient_focus AND is`disp_focus = device_focus)
	
	% The coverage TCC (at line 134, column 16) in decl nil for
	% term generated from i_down_display
	%  COND is`disp_focus = no_focus -> top_focus,
	%      is`disp_focus = top_focus -> patient_focus,
	%      is`disp_focus = patient_focus -> device_focus,
	%      is`disp_focus = device_focus -> no_focus
	% ENDCOND
	% Disjointness TCC generated (at line 147, column 0) for
	% COND is`disp_focus = top_focus -> i_select_top(is),
	%      is`disp_focus = patient_focus -> i_select_p_mode(is),
	%      is`disp_focus = device_focus -> i_select_d_mode(is),
	%      ELSE -> is
	% ENDCOND
	  % untried
	i_select_display_TCC1: OBLIGATION
	FORALL (xs: interface_st, is: i_state[maxrate, maxinfuse, maxtime]):
	    is = xs`ss`coord_st IMPLIES
	     NOT (is`disp_focus = top_focus AND is`disp_focus = patient_focus) AND
	      NOT (is`disp_focus = top_focus AND is`disp_focus = device_focus) AND
	       NOT (is`disp_focus = patient_focus AND is`disp_focus = device_focus)
	
	% Disjointness TCC generated (at line 190, column 0) for
	% COND is`mode = p_mode -> i_select_ap(a, is),
	%      is`mode = d_mode -> i_select_ad(a, is),
	%      ELSE -> is
	% ENDCOND
	  % untried
	i_select_action_TCC1: OBLIGATION
	FORALL (xs: interface_st, is: i_state[maxrate, maxinfuse, maxtime],
	          a: action_id):
	    is = xs`ss`coord_st AND a = (is`entry_window)`ent_action IMPLIES
	     NOT (is`mode = p_mode AND is`mode = d_mode)
	
	% Disjointness TCC generated (at line 203, column 10) for
	% COND m = select -> i_select(xs),
	%      m = cursor_up -> i_up_display(xs),
	%      m = cursor_down -> i_down_display(xs),
	%      m = display -> i_select_display(xs),
	%      m = patient_id -> i_select_patient(xs),
	%      m = device -> i_select_device(xs),
	%      m = action -> i_select_action(xs),
	%      m = escape -> i_escape(xs),
	%      ELSE -> i_escape(xs)
	% ENDCOND
	  % untried
	coord_menu_TCC1: OBLIGATION
	FORALL (m: menu):
	         (NOT (m = select AND m = cursor_up))
	     AND (NOT (m = select AND m = cursor_down))
	     AND (NOT (m = select AND m = display))
	     AND (NOT (m = select AND m = patient_id))
	     AND (NOT (m = select AND m = device)) AND (NOT (m = select AND m = action))
	     AND (NOT (m = select AND m = escape))
	     AND (NOT (m = cursor_up AND m = cursor_down))
	     AND (NOT (m = cursor_up AND m = display))
	     AND (NOT (m = cursor_up AND m = patient_id))
	     AND (NOT (m = cursor_up AND m = device))
	     AND (NOT (m = cursor_up AND m = action))
	     AND (NOT (m = cursor_up AND m = escape))
	     AND (NOT (m = cursor_down AND m = display))
	     AND (NOT (m = cursor_down AND m = patient_id))
	     AND (NOT (m = cursor_down AND m = device))
	     AND (NOT (m = cursor_down AND m = action))
	     AND (NOT (m = cursor_down AND m = escape))
	     AND (NOT (m = display AND m = patient_id))
	     AND (NOT (m = display AND m = device))
	     AND (NOT (m = display AND m = action))
	     AND (NOT (m = display AND m = escape))
	     AND (NOT (m = patient_id AND m = device))
	     AND (NOT (m = patient_id AND m = action))
	     AND (NOT (m = patient_id AND m = escape))
	     AND (NOT (m = device AND m = action)) AND (NOT (m = device AND m = escape))
	     AND NOT (m = action AND m = escape)
	
	% Disjointness TCC generated (at line 230, column 0) for
	% COND per_p_edit(ps) ->
	%        LET xs1 =
	%              xs
	%                WITH [ms
	%                        := xs`ms
	%                             WITH [patient_mn
	%                                   := LAMBDA
	%                                      (p1: patient):
	%                                      IF p1 = p
	%                                      THEN xs`ms`patient_mn(p)
	%                                           WITH [prev_menu
	%                                                 := xs`ms`patient_mn
	%                                                    (p)`visible_menu]
	%                                      ELSE xs`ms`patient_mn(p1)
	%                                      ENDIF]]
	%          IN
	%          xs1 WITH [ms := p_change_menu(edit_options_menu, p, xs`ms)],
	%      (ps`pmode = d_mode) AND (ps`emode = edit_rule) ->
	%        LET xs1 =
	%              xs
	%                WITH [ms
	%                        := xs`ms
	%                             WITH [patient_mn
	%                                   := LAMBDA
	%                                      (p1: patient):
	%                                      IF p1 = p
	%                                      THEN xs`ms`patient_mn(p)
	%                                           WITH [prev_menu
	%                                                 := xs`ms`patient_mn
	%                                                    (p)`visible_menu]
	%                                      ELSE xs`ms`patient_mn(p1)
	%                                      ENDIF]]
	%          IN
	%          xs1
	%            WITH [ms
	%                    := p_change_menu(LAMBDA
	%                                     (m: menu):
	%                                     (m = constraint) OR (m = escape),
	%                                     p,
	%                                     xs`ms)],
	%      ELSE -> p_escape(p, xs)
	% ENDCOND
	  % untried
	p_edit_TCC1: OBLIGATION
	FORALL (p: patient, xs: interface_st,
	          ps: p_state[maxrate, maxinfuse, maxtime]):
	    ps = xs`ss`pdb(p) IMPLIES
	     NOT (per_p_edit[maxrate, maxinfuse, maxtime](ps) AND
	           (ps`pmode = d_mode) AND (ps`emode = edit_rule))
	
	% Disjointness TCC generated (at line 273, column 0) for
	% COND pm`previous_entry = edit -> p_edit_constraint(p, xs),
	%      pm`previous_entry = cursor_up ->
	%        mapping_to_ps(p_scroll_up_rule, p, xs)
	%          WITH [ms := p_change_menu(pm`prev_menu, p, xs`ms)],
	%      pm`previous_entry = cursor_down ->
	%        mapping_to_ps(p_scroll_down_rule, p, xs)
	%          WITH [ms := p_change_menu(pm`prev_menu, p, xs`ms)],
	%      ELSE -> p_escape(p, xs)
	% ENDCOND
	  % untried
	p_constraint_TCC1: OBLIGATION
	FORALL (p: patient, xs: interface_st, pm: menu_state):
	    pm = xs`ms`patient_mn(p) IMPLIES
	     NOT (pm`previous_entry = edit AND pm`previous_entry = cursor_up) AND
	      NOT (pm`previous_entry = edit AND pm`previous_entry = cursor_down) AND
	       NOT (pm`previous_entry = cursor_up AND pm`previous_entry = cursor_down)
	
	% Disjointness TCC generated (at line 296, column 0) for
	% COND ps`emode = edit_none ->
	%        xs
	%          WITH [ms
	%                  := p_change_menu(LAMBDA
	%                                   (m: menu):
	%                                        (m = device)
	%                                    OR (m = escape)
	%                                    OR (m = display)
	%                                    OR (m = device_filter)
	%                                    OR (m = region),
	%                                   p,
	%                                   xs`ms)],
	%      ps`emode = edit_top ->
	%        xs
	%          WITH [ms
	%                  := p_change_menu(LAMBDA
	%                                   (m: menu):
	%                                   (m = parameter) OR (m = escape),
	%                                   p,
	%                                   xs`ms)],
	%      (ps`emode = edit_patient) OR (ps`emode = edit_device) ->
	%        xs
	%          WITH [ms
	%                  := p_change_menu(LAMBDA
	%                                   (m: menu):
	%                                   (m = parameter)
	%                                   OR
	%                                   (m = action) OR (m = escape),
	%                                   p,
	%                                   xs`ms)],
	%      (ps`emode = edit_constraint) ->
	%        xs
	%          WITH [ms
	%                  := p_change_menu(LAMBDA
	%                                   (m: menu):
	%                                        (m = parameter)
	%                                    OR (m = relation)
	%                                    OR (m = num_value)
	%                                    OR (m = enum_value)
	%                                    OR (m = escape),
	%                                   p,
	%                                   xs`ms)],
	%      (ps`emode = edit_rule) ->
	%        xs
	%          WITH [ms
	%                  := p_change_menu(LAMBDA
	%                                   (m: menu):
	%                                        (m = action)
	%                                    OR (m = escape)
	%                                    OR (m = device)
	%                                    OR (m = display)
	%                                    OR (m = escape)
	%                                    OR (m = region),
	%                                   p,
	%                                   xs`ms)],
	%      ELSE -> xs
	% ENDCOND
	  % untried
	p_select_TCC1: OBLIGATION
	FORALL (p: patient, xs: interface_st,
	          ps: p_state[maxrate, maxinfuse, maxtime]):
	    ps = xs`ss`pdb(p) IMPLIES
	          (NOT (ps`emode = edit_none AND ps`emode = edit_top))
	      AND (NOT (ps`emode = edit_none AND
	                 ((ps`emode = edit_patient) OR (ps`emode = edit_device))))
	      AND (NOT (ps`emode = edit_none AND (ps`emode = edit_constraint)))
	      AND (NOT (ps`emode = edit_none AND (ps`emode = edit_rule)))
	      AND (NOT (ps`emode = edit_top AND
	                 ((ps`emode = edit_patient) OR (ps`emode = edit_device))))
	      AND (NOT (ps`emode = edit_top AND (ps`emode = edit_constraint)))
	      AND (NOT (ps`emode = edit_top AND (ps`emode = edit_rule)))
	      AND (NOT (((ps`emode = edit_patient) OR (ps`emode = edit_device)) AND
	                 (ps`emode = edit_constraint)))
	      AND (NOT (((ps`emode = edit_patient) OR (ps`emode = edit_device)) AND
	                 (ps`emode = edit_rule)))
	      AND NOT ((ps`emode = edit_constraint) AND (ps`emode = edit_rule))
	
	% The disjointness TCC (at line 345, column 5) in decl nil for
	% term generated from patient_enter_relation
	%  COND enum_par(par) AND ((r = eq) OR (r = neq)) -> r,
	%      num_par(par) -> r,
	%      ELSE -> eq
	% ENDCOND
	% was not generated because it simplifies to TRUE.
	% Disjointness TCC generated (at line 431, column 3) for
	% COND ps`disp_focus = top_focus -> p_edit_top(p, xs),
	%      ps`disp_focus = patient_focus -> p_edit_main(p, xs),
	%      ps`disp_focus = device_focus -> p_edit_device(p, xs),
	%      ELSE -> xs
	% ENDCOND
	  % untried
	p_edit_region_TCC1: OBLIGATION
	FORALL (p: patient, xs: interface_st,
	          ps: p_state[maxrate, maxinfuse, maxtime]):
	    ps = xs`ss`pdb(p) AND per_p_edit(ps) IMPLIES
	     NOT (ps`disp_focus = top_focus AND ps`disp_focus = patient_focus) AND
	      NOT (ps`disp_focus = top_focus AND ps`disp_focus = device_focus) AND
	       NOT (ps`disp_focus = patient_focus AND ps`disp_focus = device_focus)
	
	% Disjointness TCC generated (at line 440, column 2) for
	% COND pm`previous_entry = edit -> p_edit_region(p, xs),
	%      pm`previous_entry = select -> p_select_region(p, xs),
	%      pm`previous_entry = cursor_up -> p_up_display(p, xs),
	%      pm`previous_entry = cursor_down -> p_down_display(p, xs),
	%      ELSE -> p_escape(p, xs)
	% ENDCOND
	  % untried
	p_region_TCC1: OBLIGATION
	FORALL (p: patient, xs: interface_st, pm: menu_state):
	    pm = xs`ms`patient_mn(p) IMPLIES
	          (NOT (pm`previous_entry = edit AND pm`previous_entry = select))
	      AND (NOT (pm`previous_entry = edit AND pm`previous_entry = cursor_up))
	      AND (NOT (pm`previous_entry = edit AND pm`previous_entry = cursor_down))
	      AND (NOT (pm`previous_entry = select AND pm`previous_entry = cursor_up))
	      AND (NOT (pm`previous_entry = select AND pm`previous_entry = cursor_down))
	      AND NOT (pm`previous_entry = cursor_up AND
	                pm`previous_entry = cursor_down)
	
	% Disjointness TCC generated (at line 453, column 0) for
	% COND xs`ms`patient_mn(p)`previous_entry = select ->
	%        mapping_to_ps(p_select_enum_value, p, xs),
	%      xs`ms`patient_mn(p)`previous_entry = clear ->
	%        mapping_to_ps(p_clear_enum_value, p, xs),
	%      ELSE -> xs
	% ENDCOND
	  % untried
	p_enum_value_TCC1: OBLIGATION
	FORALL (p: patient, xs: interface_st):
	    NOT (xs`ms`patient_mn(p)`previous_entry = select AND
	          xs`ms`patient_mn(p)`previous_entry = clear)
	
	% The disjointness TCC (at line 463, column 0) in decl nil for
	% term generated from p_num_value
	%  COND xs`ms`patient_mn(p)`previous_entry = select ->
	%        mapping_to_ps(p_select_num_value, p, xs),
	%      xs`ms`patient_mn(p)`previous_entry = clear ->
	%        mapping_to_ps(p_clear_num_value, p, xs),
	%      ELSE -> xs
	% ENDCOND
	% Disjointness TCC generated (at line 505, column 4) for
	% COND (pm`previous_entry = select) -> p_select_display_mode(p, xs),
	%      pm`previous_entry = enter -> p_device_entry(p, xs),
	%      pm`previous_entry = edit -> p_edit_device(p, xs),
	%      ELSE -> p_escape(p, xs)
	% ENDCOND
	  % untried
	p_device_TCC1: OBLIGATION
	FORALL (p: patient, xs: interface_st,
	          ps: p_state[maxrate, maxinfuse, maxtime], pm: menu_state):
	    ps = xs`ss`pdb(p) AND
	     pm = xs`ms`patient_mn(p) AND
	      ((ps`emode = edit_none) OR (ps`emode = edit_rule))
	     IMPLIES
	     NOT ((pm`previous_entry = select) AND pm`previous_entry = enter) AND
	      NOT ((pm`previous_entry = select) AND pm`previous_entry = edit) AND
	       NOT (pm`previous_entry = enter AND pm`previous_entry = edit)
	
	% Disjointness TCC generated (at line 557, column 3) for
	% COND per_p_select(ps) ->
	%        xs
	%          WITH [ss
	%                  := xs`ss
	%                       WITH [pdb
	%                               := LAMBDA
	%                                  (p1: patient):
	%                                  IF p1 = p
	%                                  THEN ps
	%                                       WITH [p_panel_display
	%                                             := ps`p_panel_display
	%                                                WITH [select_pars
	%                                                      := add
	%                                                         ((ps`p_entry_window)`ent_par,
	%                                                          (ps`p_panel_display)`select_pars)]]
	%                                  ELSE xs`ss`pdb(p1)
	%                                  ENDIF],
	%                ms := p_change_menu(edit_menu, p, xs`ms)],
	%      per_e_select(ps) ->
	%        xs
	%          WITH [ss
	%                  := xs`ss
	%                       WITH [pdb
	%                               := LAMBDA
	%                                  (p1: patient):
	%                                  IF p1 = p
	%                                  THEN ps
	%                                       WITH [p_constraint_display
	%                                             := ps`p_constraint_display
	%                                                WITH [select_par
	%                                                      := (ps`p_entry_window)`ent_par]]
	%                                  ELSE xs`ss`pdb(p1)
	%                                  ENDIF],
	%                ms := p_change_menu(edit_constraint_menu, p, xs`ms)],
	%      ELSE -> xs
	% ENDCOND
	  % untried
	p_select_par_TCC1: OBLIGATION
	FORALL (p: patient, xs: interface_st,
	          ps: p_state[maxrate, maxinfuse, maxtime]):
	    ps = xs`ss`pdb(p) AND (ps`p_disp_device)`pars((ps`p_entry_window)`ent_par)
	     IMPLIES
	     NOT (per_p_select[maxrate, maxinfuse, maxtime](ps) AND
	           per_e_select[maxrate, maxinfuse, maxtime](ps))
	
	% Disjointness TCC generated (at line 585, column 0) for
	% COND (ps`emode = edit_top) OR
	%       (ps`emode = edit_device) OR (ps`emode = edit_patient)
	%        ->
	%        mapping_to_ps(p_quit_patient, p, xs)
	%          WITH [ms := p_change_menu(edit_none_menu, p, xs`ms)],
	%      (ps`emode = edit_constraint) ->
	%        mapping_to_ps(p_quit_constraint, p, xs)
	%          WITH [ms := p_change_menu(edit_rule_menu, p, xs`ms)],
	%      (ps`emode = edit_rule) ->
	%        mapping_to_ps(p_quit_rule, p, xs)
	%          WITH [ms := p_change_menu(edit_none_menu, p, xs`ms)],
	%      ELSE -> xs
	% ENDCOND
	  % untried
	act_patient_quit_TCC1: OBLIGATION
	FORALL (p: patient, xs: interface_st,
	          ps: p_state[maxrate, maxinfuse, maxtime]):
	    ps = xs`ss`pdb(p) AND (((ps`p_disp_top)`sel_device)`dv /= nil_device)
	     IMPLIES
	     NOT (((ps`emode = edit_top) OR
	            (ps`emode = edit_device) OR (ps`emode = edit_patient))
	           AND (ps`emode = edit_constraint))
	      AND
	      NOT (((ps`emode = edit_top) OR
	             (ps`emode = edit_device) OR (ps`emode = edit_patient))
	            AND (ps`emode = edit_rule))
	       AND NOT ((ps`emode = edit_constraint) AND (ps`emode = edit_rule))
	
	% Disjointness TCC generated (at line 621, column 3) for
	% COND per_a_select(ps) ->
	%        xs
	%          WITH [ms := p_change_menu(edit_none_menu, p, xs`ms),
	%                ss := patient_act_mono(p, xs`ss)],
	%      per_a_d_r_select(ps) ->
	%        xs
	%          WITH [ms := p_change_menu(edit_menu, p, xs`ms),
	%                ss
	%                  := xs`ss
	%                       WITH [pdb
	%                               := LAMBDA
	%                                  (p1: patient):
	%                                  IF p1 = p
	%                                  THEN xs`ss`pdb(p)
	%                                       WITH [p_panel_display
	%                                             := ps`p_panel_display
	%                                                WITH [select_acts
	%                                                      := add
	%                                                         (a,
	%                                                          (ps`p_panel_display)`select_acts)]]
	%                                  ELSE xs`ss`pdb(p1)
	%                                  ENDIF]],
	%      per_a_rule_select(ps) ->
	%        xs
	%          WITH [ms := p_change_menu(edit_rule_menu, p, xs`ms),
	%                ss
	%                  := xs`ss
	%                       WITH [pdb
	%                               := LAMBDA
	%                                  (p1: patient):
	%                                  IF p1 = p
	%                                  THEN xs`ss`pdb(p)
	%                                       WITH [p_rules_display
	%                                             := ps`p_rules_display
	%                                                WITH [select_act
	%                                                      := a]]
	%                                  ELSE xs`ss`pdb(p1)
	%                                  ENDIF]],
	%      ELSE -> xs
	% ENDCOND
	  % untried
	p_select_a_TCC1: OBLIGATION
	FORALL (p: patient, xs: interface_st,
	          ps: p_state[maxrate, maxinfuse, maxtime], a: action_id):
	    ps = xs`ss`pdb(p) AND
	     a = (ps`p_entry_window)`ent_act AND (ps`p_disp_device)`cmds(a)
	     IMPLIES
	     NOT (per_a_select[maxrate, maxinfuse, maxtime](ps) AND
	           per_a_d_r_select[maxrate, maxinfuse, maxtime](ps))
	      AND
	      NOT (per_a_select[maxrate, maxinfuse, maxtime](ps) AND
	            per_a_rule_select[maxrate, maxinfuse, maxtime](ps))
	       AND
	       NOT (per_a_d_r_select[maxrate, maxinfuse, maxtime](ps) AND
	             per_a_rule_select[maxrate, maxinfuse, maxtime](ps))
	
	% Disjointness TCC generated (at line 653, column 9) for
	% COND m = escape -> p_escape(p, xs),
	%      m = cursor_up -> p_cursor_move(p, xs),
	%      m = cursor_down -> p_cursor_move(p, xs),
	%      m = constraint -> p_constraint(p, xs),
	%      m = delete -> p_delete_rule(p, xs),
	%      m = clear -> p_clear(p, xs),
	%      m = select -> p_select(p, xs),
	%      m = parameter -> p_select_par(p, xs),
	%      m = relation -> p_select_relation(p, xs),
	%      m = action -> p_select_a(p, xs),
	%      m = display -> p_select_region(p, xs),
	%      m = enum_value -> p_enum_value(p, xs),
	%      m = num_value -> p_num_value(p, xs),
	%      m = edit -> p_edit(p, xs),
	%      m = top -> p_edit_top(p, xs),
	%      m = main -> p_edit_main(p, xs),
	%      m = region -> p_region(p, xs),
	%      m = device -> p_device(p, xs),
	%      m = device_filter -> p_device_filter(p, xs),
	%      m = enter -> p_enter(p, xs),
	%      m = pump -> p_complete_device_p(p, xs),
	%      m = vs_device -> p_complete_device_vs(p, xs),
	%      ELSE -> p_escape(p, xs)
	% ENDCOND
	  % untried
	patient_menu_TCC1: OBLIGATION
	FORALL (m: menu):
	         (NOT (m = escape AND m = cursor_up))
	     AND (NOT (m = escape AND m = cursor_down))
	     AND (NOT (m = escape AND m = constraint))
	     AND (NOT (m = escape AND m = delete)) AND (NOT (m = escape AND m = clear))
	     AND (NOT (m = escape AND m = select))
	     AND (NOT (m = escape AND m = parameter))
	     AND (NOT (m = escape AND m = relation))
	     AND (NOT (m = escape AND m = action))
	     AND (NOT (m = escape AND m = display))
	     AND (NOT (m = escape AND m = enum_value))
	     AND (NOT (m = escape AND m = num_value))
	     AND (NOT (m = escape AND m = edit)) AND (NOT (m = escape AND m = top))
	     AND (NOT (m = escape AND m = main)) AND (NOT (m = escape AND m = region))
	     AND (NOT (m = escape AND m = device))
	     AND (NOT (m = escape AND m = device_filter))
	     AND (NOT (m = escape AND m = enter)) AND (NOT (m = escape AND m = pump))
	     AND (NOT (m = escape AND m = vs_device))
	     AND (NOT (m = cursor_up AND m = constraint))
	     AND (NOT (m = cursor_up AND m = delete))
	     AND (NOT (m = cursor_up AND m = clear))
	     AND (NOT (m = cursor_up AND m = select))
	     AND (NOT (m = cursor_up AND m = parameter))
	     AND (NOT (m = cursor_up AND m = relation))
	     AND (NOT (m = cursor_up AND m = action))
	     AND (NOT (m = cursor_up AND m = display))
	     AND (NOT (m = cursor_up AND m = enum_value))
	     AND (NOT (m = cursor_up AND m = num_value))
	     AND (NOT (m = cursor_up AND m = edit))
	     AND (NOT (m = cursor_up AND m = top))
	     AND (NOT (m = cursor_up AND m = main))
	     AND (NOT (m = cursor_up AND m = region))
	     AND (NOT (m = cursor_up AND m = device))
	     AND (NOT (m = cursor_up AND m = device_filter))
	     AND (NOT (m = cursor_up AND m = enter))
	     AND (NOT (m = cursor_up AND m = pump))
	     AND (NOT (m = cursor_up AND m = vs_device))
	     AND (NOT (m = cursor_down AND m = constraint))
	     AND (NOT (m = cursor_down AND m = delete))
	     AND (NOT (m = cursor_down AND m = clear))
	     AND (NOT (m = cursor_down AND m = select))
	     AND (NOT (m = cursor_down AND m = parameter))
	     AND (NOT (m = cursor_down AND m = relation))
	     AND (NOT (m = cursor_down AND m = action))
	     AND (NOT (m = cursor_down AND m = display))
	     AND (NOT (m = cursor_down AND m = enum_value))
	     AND (NOT (m = cursor_down AND m = num_value))
	     AND (NOT (m = cursor_down AND m = edit))
	     AND (NOT (m = cursor_down AND m = top))
	     AND (NOT (m = cursor_down AND m = main))
	     AND (NOT (m = cursor_down AND m = region))
	     AND (NOT (m = cursor_down AND m = device))
	     AND (NOT (m = cursor_down AND m = device_filter))
	     AND (NOT (m = cursor_down AND m = enter))
	     AND (NOT (m = cursor_down AND m = pump))
	     AND (NOT (m = cursor_down AND m = vs_device))
	     AND (NOT (m = constraint AND m = delete))
	     AND (NOT (m = constraint AND m = clear))
	     AND (NOT (m = constraint AND m = select))
	     AND (NOT (m = constraint AND m = parameter))
	     AND (NOT (m = constraint AND m = relation))
	     AND (NOT (m = constraint AND m = action))
	     AND (NOT (m = constraint AND m = display))
	     AND (NOT (m = constraint AND m = enum_value))
	     AND (NOT (m = constraint AND m = num_value))
	     AND (NOT (m = constraint AND m = edit))
	     AND (NOT (m = constraint AND m = top))
	     AND (NOT (m = constraint AND m = main))
	     AND (NOT (m = constraint AND m = region))
	     AND (NOT (m = constraint AND m = device))
	     AND (NOT (m = constraint AND m = device_filter))
	     AND (NOT (m = constraint AND m = enter))
	     AND (NOT (m = constraint AND m = pump))
	     AND (NOT (m = constraint AND m = vs_device))
	     AND (NOT (m = delete AND m = clear)) AND (NOT (m = delete AND m = select))
	     AND (NOT (m = delete AND m = parameter))
	     AND (NOT (m = delete AND m = relation))
	     AND (NOT (m = delete AND m = action))
	     AND (NOT (m = delete AND m = display))
	     AND (NOT (m = delete AND m = enum_value))
	     AND (NOT (m = delete AND m = num_value))
	     AND (NOT (m = delete AND m = edit)) AND (NOT (m = delete AND m = top))
	     AND (NOT (m = delete AND m = main)) AND (NOT (m = delete AND m = region))
	     AND (NOT (m = delete AND m = device))
	     AND (NOT (m = delete AND m = device_filter))
	     AND (NOT (m = delete AND m = enter)) AND (NOT (m = delete AND m = pump))
	     AND (NOT (m = delete AND m = vs_device))
	     AND (NOT (m = clear AND m = select))
	     AND (NOT (m = clear AND m = parameter))
	     AND (NOT (m = clear AND m = relation)) AND (NOT (m = clear AND m = action))
	     AND (NOT (m = clear AND m = display))
	     AND (NOT (m = clear AND m = enum_value))
	     AND (NOT (m = clear AND m = num_value)) AND (NOT (m = clear AND m = edit))
	     AND (NOT (m = clear AND m = top)) AND (NOT (m = clear AND m = main))
	     AND (NOT (m = clear AND m = region)) AND (NOT (m = clear AND m = device))
	     AND (NOT (m = clear AND m = device_filter))
	     AND (NOT (m = clear AND m = enter)) AND (NOT (m = clear AND m = pump))
	     AND (NOT (m = clear AND m = vs_device))
	     AND (NOT (m = select AND m = parameter))
	     AND (NOT (m = select AND m = relation))
	     AND (NOT (m = select AND m = action))
	     AND (NOT (m = select AND m = display))
	     AND (NOT (m = select AND m = enum_value))
	     AND (NOT (m = select AND m = num_value))
	     AND (NOT (m = select AND m = edit)) AND (NOT (m = select AND m = top))
	     AND (NOT (m = select AND m = main)) AND (NOT (m = select AND m = region))
	     AND (NOT (m = select AND m = device))
	     AND (NOT (m = select AND m = device_filter))
	     AND (NOT (m = select AND m = enter)) AND (NOT (m = select AND m = pump))
	     AND (NOT (m = select AND m = vs_device))
	     AND (NOT (m = parameter AND m = relation))
	     AND (NOT (m = parameter AND m = action))
	     AND (NOT (m = parameter AND m = display))
	     AND (NOT (m = parameter AND m = enum_value))
	     AND (NOT (m = parameter AND m = num_value))
	     AND (NOT (m = parameter AND m = edit))
	     AND (NOT (m = parameter AND m = top))
	     AND (NOT (m = parameter AND m = main))
	     AND (NOT (m = parameter AND m = region))
	     AND (NOT (m = parameter AND m = device))
	     AND (NOT (m = parameter AND m = device_filter))
	     AND (NOT (m = parameter AND m = enter))
	     AND (NOT (m = parameter AND m = pump))
	     AND (NOT (m = parameter AND m = vs_device))
	     AND (NOT (m = relation AND m = action))
	     AND (NOT (m = relation AND m = display))
	     AND (NOT (m = relation AND m = enum_value))
	     AND (NOT (m = relation AND m = num_value))
	     AND (NOT (m = relation AND m = edit)) AND (NOT (m = relation AND m = top))
	     AND (NOT (m = relation AND m = main))
	     AND (NOT (m = relation AND m = region))
	     AND (NOT (m = relation AND m = device))
	     AND (NOT (m = relation AND m = device_filter))
	     AND (NOT (m = relation AND m = enter))
	     AND (NOT (m = relation AND m = pump))
	     AND (NOT (m = relation AND m = vs_device))
	     AND (NOT (m = action AND m = display))
	     AND (NOT (m = action AND m = enum_value))
	     AND (NOT (m = action AND m = num_value))
	     AND (NOT (m = action AND m = edit)) AND (NOT (m = action AND m = top))
	     AND (NOT (m = action AND m = main)) AND (NOT (m = action AND m = region))
	     AND (NOT (m = action AND m = device))
	     AND (NOT (m = action AND m = device_filter))
	     AND (NOT (m = action AND m = enter)) AND (NOT (m = action AND m = pump))
	     AND (NOT (m = action AND m = vs_device))
	     AND (NOT (m = display AND m = enum_value))
	     AND (NOT (m = display AND m = num_value))
	     AND (NOT (m = display AND m = edit)) AND (NOT (m = display AND m = top))
	     AND (NOT (m = display AND m = main)) AND (NOT (m = display AND m = region))
	     AND (NOT (m = display AND m = device))
	     AND (NOT (m = display AND m = device_filter))
	     AND (NOT (m = display AND m = enter)) AND (NOT (m = display AND m = pump))
	     AND (NOT (m = display AND m = vs_device))
	     AND (NOT (m = enum_value AND m = num_value))
	     AND (NOT (m = enum_value AND m = edit))
	     AND (NOT (m = enum_value AND m = top))
	     AND (NOT (m = enum_value AND m = main))
	     AND (NOT (m = enum_value AND m = region))
	     AND (NOT (m = enum_value AND m = device))
	     AND (NOT (m = enum_value AND m = device_filter))
	     AND (NOT (m = enum_value AND m = enter))
	     AND (NOT (m = enum_value AND m = pump))
	     AND (NOT (m = enum_value AND m = vs_device))
	     AND (NOT (m = num_value AND m = edit))
	     AND (NOT (m = num_value AND m = top))
	     AND (NOT (m = num_value AND m = main))
	     AND (NOT (m = num_value AND m = region))
	     AND (NOT (m = num_value AND m = device))
	     AND (NOT (m = num_value AND m = device_filter))
	     AND (NOT (m = num_value AND m = enter))
	     AND (NOT (m = num_value AND m = pump))
	     AND (NOT (m = num_value AND m = vs_device))
	     AND (NOT (m = edit AND m = top)) AND (NOT (m = edit AND m = main))
	     AND (NOT (m = edit AND m = region)) AND (NOT (m = edit AND m = device))
	     AND (NOT (m = edit AND m = device_filter))
	     AND (NOT (m = edit AND m = enter)) AND (NOT (m = edit AND m = pump))
	     AND (NOT (m = edit AND m = vs_device)) AND (NOT (m = top AND m = main))
	     AND (NOT (m = top AND m = region)) AND (NOT (m = top AND m = device))
	     AND (NOT (m = top AND m = device_filter)) AND (NOT (m = top AND m = enter))
	     AND (NOT (m = top AND m = pump)) AND (NOT (m = top AND m = vs_device))
	     AND (NOT (m = main AND m = region)) AND (NOT (m = main AND m = device))
	     AND (NOT (m = main AND m = device_filter))
	     AND (NOT (m = main AND m = enter)) AND (NOT (m = main AND m = pump))
	     AND (NOT (m = main AND m = vs_device))
	     AND (NOT (m = region AND m = device))
	     AND (NOT (m = region AND m = device_filter))
	     AND (NOT (m = region AND m = enter)) AND (NOT (m = region AND m = pump))
	     AND (NOT (m = region AND m = vs_device))
	     AND (NOT (m = device AND m = device_filter))
	     AND (NOT (m = device AND m = enter)) AND (NOT (m = device AND m = pump))
	     AND (NOT (m = device AND m = vs_device))
	     AND (NOT (m = device_filter AND m = enter))
	     AND (NOT (m = device_filter AND m = pump))
	     AND (NOT (m = device_filter AND m = vs_device))
	     AND (NOT (m = enter AND m = pump)) AND (NOT (m = enter AND m = vs_device))
	     AND NOT (m = pump AND m = vs_device)
	
	% Disjointness TCC generated (at line 717, column 3) for
	% COND n1 = coord_node ->
	%        st
	%          WITH [coord_st
	%                  := update_patient_alarm_disp(st`p_nodes(n2),
	%                                               ne`chan_error,
	%                                               st`coord_st)],
	%      n1 /= coord_node AND
	%       st`p_nodes(n1) /= p_null AND n2 = coord_node
	%        ->
	%        st
	%          WITH [coord_st
	%                  := update_patient_alarm_disp(st`p_nodes(n1),
	%                                               ne`chan_error,
	%                                               st`coord_st)],
	%      n1 /= coord_node AND
	%       st`p_nodes(n1) /= p_null AND n2 /= coord_node
	%        ->
	%        st
	%          WITH [coord_st
	%                  := update_patient_alarm_disp(st`p_nodes(n1),
	%                                               ne`chan_error,
	%                                               st`coord_st)],
	%      n1 /= coord_node AND
	%       st`p_nodes(n1) = p_null AND st`p_nodes(n2) /= p_null
	%        ->
	%        st
	%          WITH [coord_st
	%                  := update_patient_device_alarm_disp(st`p_nodes(n2),
	%                                                      st`d_nodes
	%                                                      (n2)`dev,
	%                                                      ne`chan_error,
	%                                                      st`coord_st)],
	%      n1 /= coord_node AND
	%       st`p_nodes(n1) = p_null AND st`p_nodes(n2) = p_null
	%        ->
	%        st
	%          WITH [coord_st
	%                  := update_patient_device_alarm_disp(p_null,
	%                                                      nil_device,
	%                                                      spurious_action,
	%                                                      st`coord_st)]
	% ENDCOND
	  % proved
	act_error_TCC1: OBLIGATION
	FORALL (st: state, ns: n_state[maxrate, maxinfuse, maxtime],
	          ne: network_error_type[maxrate, maxinfuse, maxtime],
	          n1: node[maxrate, maxinfuse, maxtime],
	          n2: node[maxrate, maxinfuse, maxtime]):
	    ns = st`nde_state AND
	     ne = ns`nw_error AND n1 = ne`nsource AND n2 = ne`ndest
	     IMPLIES
	          (NOT (n1 = coord_node[maxrate, maxinfuse, maxtime] AND
	                 n1 /= coord_node[maxrate, maxinfuse, maxtime] AND
	                  st`p_nodes(n1) /= p_null[maxrate, maxinfuse, maxtime] AND
	                   n2 = coord_node[maxrate, maxinfuse, maxtime]))
	      AND (NOT (n1 = coord_node[maxrate, maxinfuse, maxtime] AND
	                 n1 /= coord_node[maxrate, maxinfuse, maxtime] AND
	                  st`p_nodes(n1) /= p_null[maxrate, maxinfuse, maxtime] AND
	                   n2 /= coord_node[maxrate, maxinfuse, maxtime]))
	      AND (NOT (n1 = coord_node[maxrate, maxinfuse, maxtime] AND
	                 n1 /= coord_node[maxrate, maxinfuse, maxtime] AND
	                  st`p_nodes(n1) = p_null[maxrate, maxinfuse, maxtime] AND
	                   st`p_nodes(n2) /= p_null[maxrate, maxinfuse, maxtime]))
	      AND (NOT (n1 = coord_node[maxrate, maxinfuse, maxtime] AND
	                 n1 /= coord_node[maxrate, maxinfuse, maxtime] AND
	                  st`p_nodes(n1) = p_null[maxrate, maxinfuse, maxtime] AND
	                   st`p_nodes(n2) = p_null[maxrate, maxinfuse, maxtime]))
	      AND (NOT (     (n1 /= coord_node[maxrate, maxinfuse, maxtime])
	                 AND (st`p_nodes(n1) /= p_null[maxrate, maxinfuse, maxtime])
	                 AND (n2 = coord_node[maxrate, maxinfuse, maxtime])
	                 AND (n1 /= coord_node[maxrate, maxinfuse, maxtime])
	                 AND (st`p_nodes(n1) = p_null[maxrate, maxinfuse, maxtime])
	                 AND (st`p_nodes(n2) /= p_null[maxrate, maxinfuse, maxtime])))
	      AND (NOT (     (n1 /= coord_node[maxrate, maxinfuse, maxtime])
	                 AND (st`p_nodes(n1) /= p_null[maxrate, maxinfuse, maxtime])
	                 AND (n2 = coord_node[maxrate, maxinfuse, maxtime])
	                 AND (n1 /= coord_node[maxrate, maxinfuse, maxtime])
	                 AND (st`p_nodes(n1) = p_null[maxrate, maxinfuse, maxtime])
	                 AND (st`p_nodes(n2) = p_null[maxrate, maxinfuse, maxtime])))
	      AND (NOT (     (n1 /= coord_node[maxrate, maxinfuse, maxtime])
	                 AND (st`p_nodes(n1) /= p_null[maxrate, maxinfuse, maxtime])
	                 AND (n2 /= coord_node[maxrate, maxinfuse, maxtime])
	                 AND (n1 /= coord_node[maxrate, maxinfuse, maxtime])
	                 AND (st`p_nodes(n1) = p_null[maxrate, maxinfuse, maxtime])
	                 AND (st`p_nodes(n2) /= p_null[maxrate, maxinfuse, maxtime])))
	      AND (NOT (     (n1 /= coord_node[maxrate, maxinfuse, maxtime])
	                 AND (st`p_nodes(n1) /= p_null[maxrate, maxinfuse, maxtime])
	                 AND (n2 /= coord_node[maxrate, maxinfuse, maxtime])
	                 AND (n1 /= coord_node[maxrate, maxinfuse, maxtime])
	                 AND (st`p_nodes(n1) = p_null[maxrate, maxinfuse, maxtime])
	                 AND (st`p_nodes(n2) = p_null[maxrate, maxinfuse, maxtime])))
	      AND NOT (     (n1 /= coord_node[maxrate, maxinfuse, maxtime])
	                AND (st`p_nodes(n1) = p_null[maxrate, maxinfuse, maxtime])
	                AND (st`p_nodes(n2) /= p_null[maxrate, maxinfuse, maxtime])
	                AND (n1 /= coord_node[maxrate, maxinfuse, maxtime])
	                AND (st`p_nodes(n1) = p_null[maxrate, maxinfuse, maxtime])
	                AND (st`p_nodes(n2) = p_null[maxrate, maxinfuse, maxtime]))
	
	% Coverage TCC generated (at line 717, column 3) for
	% COND n1 = coord_node ->
	%        st
	%          WITH [coord_st
	%                  := update_patient_alarm_disp(st`p_nodes(n2),
	%                                               ne`chan_error,
	%                                               st`coord_st)],
	%      n1 /= coord_node AND
	%       st`p_nodes(n1) /= p_null AND n2 = coord_node
	%        ->
	%        st
	%          WITH [coord_st
	%                  := update_patient_alarm_disp(st`p_nodes(n1),
	%                                               ne`chan_error,
	%                                               st`coord_st)],
	%      n1 /= coord_node AND
	%       st`p_nodes(n1) /= p_null AND n2 /= coord_node
	%        ->
	%        st
	%          WITH [coord_st
	%                  := update_patient_alarm_disp(st`p_nodes(n1),
	%                                               ne`chan_error,
	%                                               st`coord_st)],
	%      n1 /= coord_node AND
	%       st`p_nodes(n1) = p_null AND st`p_nodes(n2) /= p_null
	%        ->
	%        st
	%          WITH [coord_st
	%                  := update_patient_device_alarm_disp(st`p_nodes(n2),
	%                                                      st`d_nodes
	%                                                      (n2)`dev,
	%                                                      ne`chan_error,
	%                                                      st`coord_st)],
	%      n1 /= coord_node AND
	%       st`p_nodes(n1) = p_null AND st`p_nodes(n2) = p_null
	%        ->
	%        st
	%          WITH [coord_st
	%                  := update_patient_device_alarm_disp(p_null,
	%                                                      nil_device,
	%                                                      spurious_action,
	%                                                      st`coord_st)]
	% ENDCOND
	  % proved
	act_error_TCC2: OBLIGATION
	FORALL (st: state, ns: n_state[maxrate, maxinfuse, maxtime],
	          ne: network_error_type[maxrate, maxinfuse, maxtime],
	          n1: node[maxrate, maxinfuse, maxtime],
	          n2: node[maxrate, maxinfuse, maxtime]):
	    ns = st`nde_state AND
	     ne = ns`nw_error AND n1 = ne`nsource AND n2 = ne`ndest
	     IMPLIES
	          (n1 = coord_node[maxrate, maxinfuse, maxtime])
	      OR (n1 /= coord_node[maxrate, maxinfuse, maxtime] AND
	           st`p_nodes(n1) /= p_null[maxrate, maxinfuse, maxtime] AND
	            n2 = coord_node[maxrate, maxinfuse, maxtime])
	      OR (n1 /= coord_node[maxrate, maxinfuse, maxtime] AND
	           st`p_nodes(n1) /= p_null[maxrate, maxinfuse, maxtime] AND
	            n2 /= coord_node[maxrate, maxinfuse, maxtime])
	      OR (n1 /= coord_node[maxrate, maxinfuse, maxtime] AND
	           st`p_nodes(n1) = p_null[maxrate, maxinfuse, maxtime] AND
	            st`p_nodes(n2) /= p_null[maxrate, maxinfuse, maxtime])
	      OR (n1 /= coord_node[maxrate, maxinfuse, maxtime] AND
	           st`p_nodes(n1) = p_null[maxrate, maxinfuse, maxtime] AND
	            st`p_nodes(n2) = p_null[maxrate, maxinfuse, maxtime])
	
	% Disjointness TCC generated (at line 835, column 7) for
	% COND m = d_mode -> p_select_d_mode(ps),
	%      m = dc_mode -> p_select_dc_mode(ps),
	%      ELSE -> p_select_top(ps)
	% ENDCOND
	  % untried
	patient_select_mode_TCC1: OBLIGATION
	FORALL (m: patient_mode_type, p: patient, st: state,
	          ps: p_state[maxrate, maxinfuse, maxtime], p1: patient):
	    ps = st`pdb(p) AND p1 = p IMPLIES NOT (m = d_mode AND m = dc_mode)
	
	% Disjointness TCC generated (at line 849, column 0) for
	% COND ps`emode = edit_device ->
	%        LET msg =
	%              (# mhdr := pmmsg,
	%                 pat_nd := pn,
	%                 msg_nd
	%                   := IF ((ps`p_disp_top)`devs(d) =
	%                           vital_signs_device)
	%                        THEN (ps`vital_signs)`nde
	%                      ELSE (ps`ip_state)(d)`nde
	%                      ENDIF,
	%                 pan := pa #)
	%          IN
	%          xs
	%            WITH [ss
	%                    := xs`ss
	%                         WITH [pdb
	%                               := LAMBDA
	%                                  (p1: patient):
	%                                  IF p1 = p
	%                                  THEN setup_device_panel(d, pa, ps)
	%                                  ELSE xs`ss`pdb(p1)
	%                                  ENDIF,
	%                               nde_state
	%                               := send_coord
	%                                  (pn, msg, xs`ss`nde_state)]],
	%      ps`emode = edit_patient ->
	%        LET msg =
	%              (# mhdr := mmmsg,
	%                 pat_nd := pn,
	%                 msg_nd
	%                   := IF ((ps`p_disp_top)`devs(d) =
	%                           vital_signs_device)
	%                        THEN (ps`vital_signs)`nde
	%                      ELSE (ps`ip_state)(d)`nde
	%                      ENDIF,
	%                 pan := pa #)
	%          IN
	%          xs
	%            WITH [ss
	%                    := xs`ss
	%                         WITH [pdb
	%                               := LAMBDA
	%                                  (p1: patient):
	%                                  IF p1 = p
	%                                  THEN setup_main_panel(d, pa, ps)
	%                                  ELSE xs`ss`pdb(p1)
	%                                  ENDIF,
	%                               nde_state
	%                               := send_coord
	%                                  (pn, msg, xs`ss`nde_state)]],
	%      ps`emode = edit_top ->
	%        LET msg =
	%              (# mhdr := tmmsg,
	%                 pat_nd := pn,
	%                 msg_nd
	%                   := IF ((ps`p_disp_top)`devs(d) =
	%                           vital_signs_device)
	%                        THEN (ps`vital_signs)`nde
	%                      ELSE (ps`ip_state)(d)`nde
	%                      ENDIF,
	%                 pan := pa #)
	%          IN
	%          xs
	%            WITH [ss
	%                    := xs`ss
	%                         WITH [pdb
	%                               := LAMBDA
	%                                  (p1: patient):
	%                                  IF p1 = p
	%                                  THEN setup_top_panel(d, pa, ps)
	%                                  ELSE xs`ss`pdb(p1)
	%                                  ENDIF,
	%                               nde_state
	%                               := send_coord
	%                                  (pn, msg, xs`ss`nde_state)]],
	%      (ps`emode = edit_constraint) ->
	%        mapping_to_ps(p_ok_constraint, p, xs)
	%          WITH [ms := p_change_menu(edit_rule_menu, p, xs`ms)],
	%      (ps`emode = edit_rule) ->
	%        mapping_to_ps(p_ok_rule, p, xs)
	%          WITH [ms := p_change_menu(edit_none_menu, p, xs`ms)],
	%      ELSE -> xs
	% ENDCOND
	  % proved
	act_patient_ok_TCC1: OBLIGATION
	FORALL (p: patient, xs: interface_st):
	    (p /= p_null) AND
	     ((((xs`ss`pdb(p))`p_disp_top)`sel_device)`dv /= nil_device)
	     IMPLIES
	     FORALL (ps: p_state[maxrate, maxinfuse, maxtime],
	             d: device[maxrate, maxinfuse, maxtime], pa: panel,
	             pn: node[maxrate, maxinfuse, maxtime]):
	       ps = xs`ss`pdb(p) AND
	        d = ((ps`p_disp_top)`sel_device)`dv AND
	         pa =
	          filter_panel(ps`patient_panels(d), ps`p_panel_display`select_pars,
	                       ps`p_panel_display`select_acts)
	          AND pn = ps`nde
	        IMPLIES
	             (NOT (ps`emode = edit_device AND ps`emode = edit_patient))
	         AND (NOT (ps`emode = edit_device AND ps`emode = edit_top))
	         AND (NOT (ps`emode = edit_device AND (ps`emode = edit_constraint)))
	         AND (NOT (ps`emode = edit_device AND (ps`emode = edit_rule)))
	         AND (NOT (ps`emode = edit_patient AND ps`emode = edit_top))
	         AND (NOT (ps`emode = edit_patient AND (ps`emode = edit_constraint)))
	         AND (NOT (ps`emode = edit_patient AND (ps`emode = edit_rule)))
	         AND (NOT (ps`emode = edit_top AND (ps`emode = edit_constraint)))
	         AND (NOT (ps`emode = edit_top AND (ps`emode = edit_rule)))
	         AND NOT ((ps`emode = edit_constraint) AND (ps`emode = edit_rule))
	
	% Disjointness TCC generated (at line 933, column 6) for
	% COND mt = tmmsg -> setup_p_t_panel(p, d, pa, st`coord_st),
	%      mt = pmmsg -> setup_p_d_panel(p, d, pa, st`coord_st),
	%      mt = mmmsg -> setup_p_m_panel(p, d, pa, st`coord_st),
	%      mt = updmsg -> update_p_panel(p, d, pa, st`coord_st),
	%      ELSE -> update_patient_alarm_disp(p, no_msg, st`coord_st)
	% ENDCOND
	  % proved
	tick_pan_coordinator_TCC1: OBLIGATION
	FORALL (st: state, ns: n_state[maxrate, maxinfuse, maxtime],
	          mg: pan_message_type[maxrate, maxinfuse, maxtime],
	          mt: msg_hdr_type[maxrate, maxinfuse, maxtime], p: patient,
	          d: device[maxrate, maxinfuse, maxtime], pa: panel):
	         (ns = st`nde_state) AND (mg = next_cm(ns)`current_pan_msg)
	     AND (mt = mg`mhdr) AND (p = st`p_nodes(mg`pat_nd))
	     AND (d = (st`d_nodes(mg`msg_nd))`dev) AND (pa = mg`pan)
	     IMPLIES
	          (NOT (mt = tmmsg[maxrate, maxinfuse, maxtime] AND
	                 mt = pmmsg[maxrate, maxinfuse, maxtime]))
	      AND (NOT (mt = tmmsg[maxrate, maxinfuse, maxtime] AND
	                 mt = mmmsg[maxrate, maxinfuse, maxtime]))
	      AND (NOT (mt = tmmsg[maxrate, maxinfuse, maxtime] AND
	                 mt = updmsg[maxrate, maxinfuse, maxtime]))
	      AND (NOT (mt = pmmsg[maxrate, maxinfuse, maxtime] AND
	                 mt = mmmsg[maxrate, maxinfuse, maxtime]))
	      AND (NOT (mt = pmmsg[maxrate, maxinfuse, maxtime] AND
	                 mt = updmsg[maxrate, maxinfuse, maxtime]))
	      AND NOT (mt = mmmsg[maxrate, maxinfuse, maxtime] AND
	                mt = updmsg[maxrate, maxinfuse, maxtime])
	
	% Disjointness TCC generated (at line 1012, column 23) for
	% COND (ps`pmode = d_mode) AND (((ps`p_disp_top)`sel_device)`dv = d) ->
	%        pa,
	%      (ps`pmode = dc_mode) AND (((ps`p_disp_top)`sel_device)`dv = d)
	%        ->
	%        filter_panel(pa, ps`filter_device_panels(d)`pars,
	%                     ps`filter_device_panels(d)`cmds),
	%      ELSE -> ps`p_disp_device
	% ENDCOND
	  % proved
	update_t_panel_TCC1: OBLIGATION
	FORALL (p: patient, d: device[maxrate, maxinfuse, maxtime],
	          pb: patient_db_type, ps: p_state[maxrate, maxinfuse, maxtime],
	          p1: patient):
	    ps = pb(p) AND p1 = p IMPLIES
	     NOT (((ps`pmode = d_mode) AND (((ps`p_disp_top)`sel_device)`dv = d)) AND
	           (ps`pmode = dc_mode) AND (((ps`p_disp_top)`sel_device)`dv = d))
	
	% Disjointness TCC generated (at line 1040, column 9) for
	% COND dtype = infusion_pump -> nde(st`pdb(p)`ip_state(dv)),
	%      dtype = vital_signs_device -> nde(ps`vital_signs),
	%      ELSE -> no_node
	% ENDCOND
	  % proved
	constraint_broken_to_coordinator_TCC1: OBLIGATION
	FORALL (p: patient, c: cindex, st: state,
	          ps: p_state[maxrate, maxinfuse, maxtime]):
	    ps = st`pdb(p) AND p_check_rule_broken(c, ps) IMPLIES
	     FORALL (dv: device[maxrate, maxinfuse, maxtime],
	             dtype: device_type[maxrate, maxinfuse, maxtime]):
	       dv = (ps`rule_set(c)`action)`dev AND dtype = ((ps`p_disp_top)`devs)(dv)
	        IMPLIES
	        NOT (dtype = infusion_pump[maxrate, maxinfuse, maxtime] AND
	              dtype = vital_signs_device[maxrate, maxinfuse, maxtime])
	
	% Subtype TCC generated (at line 1058, column 46) for  0
	% expected type  cindex
	  % proved
	check_rule_set_TCC1: OBLIGATION
	0 <= climit
	
	% Subtype TCC generated (at line 1059, column 46) for  1
	% expected type  cindex
	  % proved
	check_rule_set_TCC2: OBLIGATION
	FORALL (p: patient, st: state, st1: state):
	    st1 = constraint_broken_to_coordinator(p, 0, st) IMPLIES 1 <= climit
	
	% Subtype TCC generated (at line 1060, column 46) for  2
	% expected type  cindex
	  % proved
	check_rule_set_TCC3: OBLIGATION
	FORALL (p: patient, st: state, st1: state, st2: state):
	    st1 = constraint_broken_to_coordinator(p, 0, st) AND
	     st2 = constraint_broken_to_coordinator(p, 1, st1)
	     IMPLIES 2 <= climit
	
	% Subtype TCC generated (at line 1061, column 46) for  3
	% expected type  cindex
	  % proved
	check_rule_set_TCC4: OBLIGATION
	FORALL (p: patient, st: state, st1: state, st2: state, st3: state):
	    st1 = constraint_broken_to_coordinator(p, 0, st) AND
	     st2 = constraint_broken_to_coordinator(p, 1, st1) AND
	      st3 = constraint_broken_to_coordinator(p, 2, st2)
	     IMPLIES 3 <= climit
	
	% Subtype TCC generated (at line 1062, column 46) for  4
	% expected type  cindex
	  % proved
	check_rule_set_TCC5: OBLIGATION
	FORALL (p: patient, st: state, st1: state, st2: state, st3: state,
	          st4: state):
	    st1 = constraint_broken_to_coordinator(p, 0, st) AND
	     st2 = constraint_broken_to_coordinator(p, 1, st1) AND
	      st3 = constraint_broken_to_coordinator(p, 2, st2) AND
	       st4 = constraint_broken_to_coordinator(p, 3, st3)
	     IMPLIES 4 <= climit
	
	% Subtype TCC generated (at line 1063, column 40) for  5
	% expected type  cindex
	  % proved
	check_rule_set_TCC6: OBLIGATION
	FORALL (p: patient, st: state, st1: state, st2: state, st3: state,
	          st4: state, st5: state):
	         (st1 = constraint_broken_to_coordinator(p, 0, st))
	     AND (st2 = constraint_broken_to_coordinator(p, 1, st1))
	     AND (st3 = constraint_broken_to_coordinator(p, 2, st2))
	     AND (st4 = constraint_broken_to_coordinator(p, 3, st3))
	     AND (st5 = constraint_broken_to_coordinator(p, 4, st4))
	     IMPLIES 5 <= climit
	
	% The disjointness TCC (at line 1099, column 0) in decl nil for
	% term generated from execute_patient_device
	%  COND ((is`mode = p_mode) OR (is`mode = d_mode)) AND
	%       (is`disp_focus = patient_focus) AND
	%        (p = (is`disp_patient)`current_patient) AND
	%         (is`disp_patient)`av_main_act(d)(a)
	%        -> ex_a(a, p, d, st),
	%           (is`mode = d_mode) AND (is`disp_focus = device_focus)
	%       AND (d = (is`disp_device)`current_device)
	%       AND (p = (is`disp_patient)`current_patient)
	%       AND (is`disp_device)`av_c_disp(a)
	%        -> ex_a(a, p, d, st),
	%      ELSE ->
	%        st
	%          WITH [nde_state
	%                  := st`nde_state
	%                       WITH [nw_error
	%                               := (# nsource := st`pdb(p)`nde,
	%                                     ndest := st`coord_st`nde,
	%                                     chan_error
	%                                     := spurious_action #)]]
	% ENDCOND
	% was not generated because it simplifies to TRUE.
	% Disjointness TCC generated (at line 1133, column 2) for
	% COND ((ps`p_disp_top)`devs(d) = infusion_pump) ->
	%        LET ds = ps`ip_state(d),
	%            nd = nde(ds),
	%            ds = tick(ds),
	%            pa = available_act(ds`pan, ds),
	%            msg =
	%              (# mhdr := updmsg,
	%                 pat_nd := np,
	%                 msg_nd := nd,
	%                 pan := pa #)
	%          IN
	%          st
	%            WITH [nde_state := pan_send(nd, np, msg, ns),
	%                  pdb
	%                    := LAMBDA (p1: patient):
	%                         IF p1 = p
	%                           THEN ps
	%                                WITH [ip_state
	%                                      := LAMBDA
	%                                         (d1: device):
	%                                         IF (d1 = d)
	%                                         THEN ds
	%                                         ELSE (st`pdb(p))`ip_state(d1)
	%                                         ENDIF]
	%                         ELSE st`pdb(p1)
	%                         ENDIF],
	%      ((ps`p_disp_top)`devs(d) = vital_signs_device) ->
	%        LET vs = ps`vital_signs,
	%            nd = nde(vs),
	%            vs = tick_vs(vs),
	%            pa = available_act(vs`pan, vs),
	%            msg =
	%              (# mhdr := updmsg,
	%                 pat_nd := np,
	%                 msg_nd := nd,
	%                 pan := pa #)
	%          IN
	%          st
	%            WITH [nde_state := pan_send(nd, np, msg, ns),
	%                  pdb
	%                    := LAMBDA (p1: patient):
	%                         IF p1 = p THEN ps WITH [vital_signs := vs]
	%                         ELSE st`pdb(p1)
	%                         ENDIF],
	%      ELSE -> st
	% ENDCOND
	  % proved
	tick_pan_device_TCC1: OBLIGATION
	FORALL (d: device[maxrate, maxinfuse, maxtime], p: patient, st: state,
	          ps: p_state[maxrate, maxinfuse, maxtime],
	          np: node[maxrate, maxinfuse, maxtime],
	          ns: n_state[maxrate, maxinfuse, maxtime]):
	    ps = st`pdb(p) AND np = ps`nde AND ns = st`nde_state IMPLIES
	     NOT (((ps`p_disp_top)`devs(d) =
	            infusion_pump[maxrate, maxinfuse, maxtime])
	           AND
	           ((ps`p_disp_top)`devs(d) =
	             vital_signs_device[maxrate, maxinfuse, maxtime]))
	
	% Disjointness TCC generated (at line 1185, column 0) for
	% COND (is`mode = d_mode) AND (is`disp_focus = device_focus) ->
	%        st WITH [coord_st := i_select_ad(a, is)],
	%      ((is`mode = d_mode) OR (is`mode = p_mode)) AND
	%       (is`disp_focus = patient_focus)
	%        -> st WITH [coord_st := i_select_ap(a, is)],
	%      ELSE -> st
	% ENDCOND
	  % proved
	select_action_TCC1: OBLIGATION
	FORALL (st: state, is: i_state[maxrate, maxinfuse, maxtime]):
	    is = st`coord_st IMPLIES
	     NOT (((is`mode = d_mode) AND (is`disp_focus = device_focus)) AND
	           ((is`mode = d_mode) OR (is`mode = p_mode)) AND
	            (is`disp_focus = patient_focus))

END system_th_TCCS