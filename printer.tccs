%% TCCs associated with theory printer
%% This file was automatically generated by PVS, please **do not modify** by hand.
printer_TCCS: THEORY BEGIN

% Disjointness TCC generated (at line 15, column 3) for
	% COND a = powr -> "powr",
	%      a = alrm -> "alrm",
	%      a = incr -> "incr",
	%      a = decr -> "decr",
	%      a = bolus -> "bolus",
	%      a = confirm -> "confirm",
	%      a = choosetime -> "choosetime",
	%      a = choosevtbi -> "choosevtbi",
	%      a = chooserate -> "chooserate",
	%      a = start -> "start",
	%      a = hold -> "hold",
	%      a = tick -> "tick",
	%      a = openclamp -> "openclamp",
	%      a = closeclamp -> "closeclamp",
	%      a = nil_action -> "nil_action"
	% ENDCOND
	  % proved
	action_id2string_TCC1: OBLIGATION
	FORALL (a: action_id):
	         (NOT (a = powr AND a = alrm)) AND (NOT (a = powr AND a = incr))
	     AND (NOT (a = powr AND a = decr)) AND (NOT (a = powr AND a = bolus))
	     AND (NOT (a = powr AND a = confirm))
	     AND (NOT (a = powr AND a = choosetime))
	     AND (NOT (a = powr AND a = choosevtbi))
	     AND (NOT (a = powr AND a = chooserate)) AND (NOT (a = powr AND a = start))
	     AND (NOT (a = powr AND a = hold)) AND (NOT (a = powr AND a = tick))
	     AND (NOT (a = powr AND a = openclamp))
	     AND (NOT (a = powr AND a = closeclamp))
	     AND (NOT (a = powr AND a = nil_action)) AND (NOT (a = alrm AND a = incr))
	     AND (NOT (a = alrm AND a = decr)) AND (NOT (a = alrm AND a = bolus))
	     AND (NOT (a = alrm AND a = confirm))
	     AND (NOT (a = alrm AND a = choosetime))
	     AND (NOT (a = alrm AND a = choosevtbi))
	     AND (NOT (a = alrm AND a = chooserate)) AND (NOT (a = alrm AND a = start))
	     AND (NOT (a = alrm AND a = hold)) AND (NOT (a = alrm AND a = tick))
	     AND (NOT (a = alrm AND a = openclamp))
	     AND (NOT (a = alrm AND a = closeclamp))
	     AND (NOT (a = alrm AND a = nil_action)) AND (NOT (a = incr AND a = decr))
	     AND (NOT (a = incr AND a = bolus)) AND (NOT (a = incr AND a = confirm))
	     AND (NOT (a = incr AND a = choosetime))
	     AND (NOT (a = incr AND a = choosevtbi))
	     AND (NOT (a = incr AND a = chooserate)) AND (NOT (a = incr AND a = start))
	     AND (NOT (a = incr AND a = hold)) AND (NOT (a = incr AND a = tick))
	     AND (NOT (a = incr AND a = openclamp))
	     AND (NOT (a = incr AND a = closeclamp))
	     AND (NOT (a = incr AND a = nil_action)) AND (NOT (a = decr AND a = bolus))
	     AND (NOT (a = decr AND a = confirm))
	     AND (NOT (a = decr AND a = choosetime))
	     AND (NOT (a = decr AND a = choosevtbi))
	     AND (NOT (a = decr AND a = chooserate)) AND (NOT (a = decr AND a = start))
	     AND (NOT (a = decr AND a = hold)) AND (NOT (a = decr AND a = tick))
	     AND (NOT (a = decr AND a = openclamp))
	     AND (NOT (a = decr AND a = closeclamp))
	     AND (NOT (a = decr AND a = nil_action))
	     AND (NOT (a = bolus AND a = confirm))
	     AND (NOT (a = bolus AND a = choosetime))
	     AND (NOT (a = bolus AND a = choosevtbi))
	     AND (NOT (a = bolus AND a = chooserate))
	     AND (NOT (a = bolus AND a = start)) AND (NOT (a = bolus AND a = hold))
	     AND (NOT (a = bolus AND a = tick)) AND (NOT (a = bolus AND a = openclamp))
	     AND (NOT (a = bolus AND a = closeclamp))
	     AND (NOT (a = bolus AND a = nil_action))
	     AND (NOT (a = confirm AND a = choosetime))
	     AND (NOT (a = confirm AND a = choosevtbi))
	     AND (NOT (a = confirm AND a = chooserate))
	     AND (NOT (a = confirm AND a = start)) AND (NOT (a = confirm AND a = hold))
	     AND (NOT (a = confirm AND a = tick))
	     AND (NOT (a = confirm AND a = openclamp))
	     AND (NOT (a = confirm AND a = closeclamp))
	     AND (NOT (a = confirm AND a = nil_action))
	     AND (NOT (a = choosetime AND a = choosevtbi))
	     AND (NOT (a = choosetime AND a = chooserate))
	     AND (NOT (a = choosetime AND a = start))
	     AND (NOT (a = choosetime AND a = hold))
	     AND (NOT (a = choosetime AND a = tick))
	     AND (NOT (a = choosetime AND a = openclamp))
	     AND (NOT (a = choosetime AND a = closeclamp))
	     AND (NOT (a = choosetime AND a = nil_action))
	     AND (NOT (a = choosevtbi AND a = chooserate))
	     AND (NOT (a = choosevtbi AND a = start))
	     AND (NOT (a = choosevtbi AND a = hold))
	     AND (NOT (a = choosevtbi AND a = tick))
	     AND (NOT (a = choosevtbi AND a = openclamp))
	     AND (NOT (a = choosevtbi AND a = closeclamp))
	     AND (NOT (a = choosevtbi AND a = nil_action))
	     AND (NOT (a = chooserate AND a = start))
	     AND (NOT (a = chooserate AND a = hold))
	     AND (NOT (a = chooserate AND a = tick))
	     AND (NOT (a = chooserate AND a = openclamp))
	     AND (NOT (a = chooserate AND a = closeclamp))
	     AND (NOT (a = chooserate AND a = nil_action))
	     AND (NOT (a = start AND a = hold)) AND (NOT (a = start AND a = tick))
	     AND (NOT (a = start AND a = openclamp))
	     AND (NOT (a = start AND a = closeclamp))
	     AND (NOT (a = start AND a = nil_action)) AND (NOT (a = hold AND a = tick))
	     AND (NOT (a = hold AND a = openclamp))
	     AND (NOT (a = hold AND a = closeclamp))
	     AND (NOT (a = hold AND a = nil_action))
	     AND (NOT (a = tick AND a = openclamp))
	     AND (NOT (a = tick AND a = closeclamp))
	     AND (NOT (a = tick AND a = nil_action))
	     AND (NOT (a = openclamp AND a = closeclamp))
	     AND (NOT (a = openclamp AND a = nil_action))
	     AND NOT (a = closeclamp AND a = nil_action)
	
	% Coverage TCC generated (at line 15, column 3) for
	% COND a = powr -> "powr",
	%      a = alrm -> "alrm",
	%      a = incr -> "incr",
	%      a = decr -> "decr",
	%      a = bolus -> "bolus",
	%      a = confirm -> "confirm",
	%      a = choosetime -> "choosetime",
	%      a = choosevtbi -> "choosevtbi",
	%      a = chooserate -> "chooserate",
	%      a = start -> "start",
	%      a = hold -> "hold",
	%      a = tick -> "tick",
	%      a = openclamp -> "openclamp",
	%      a = closeclamp -> "closeclamp",
	%      a = nil_action -> "nil_action"
	% ENDCOND
	  % proved
	action_id2string_TCC2: OBLIGATION
	FORALL (a: action_id):
	         (a = powr) OR (a = alrm) OR (a = incr) OR (a = decr) OR (a = bolus)
	     OR (a = confirm) OR (a = choosetime) OR (a = choosevtbi)
	     OR (a = chooserate) OR (a = start) OR (a = hold) OR (a = tick)
	     OR (a = openclamp) OR (a = closeclamp) OR (a = nil_action)
	
	% Disjointness TCC generated (at line 55, column 2) for
	% COND r = lt -> "lt",
	%      r = le -> "le",
	%      r = gt -> "gt",
	%      r = ge -> "ge",
	%      r = eq -> "eq",
	%      r = neq -> "neq",
	%      r = no_rel -> "no_rel"
	% ENDCOND
	  % proved
	rel_op_type2string_TCC1: OBLIGATION
	FORALL (r: rel_op_type):
	         (NOT (r = lt AND r = le)) AND (NOT (r = lt AND r = gt))
	     AND (NOT (r = lt AND r = ge)) AND (NOT (r = lt AND r = eq))
	     AND (NOT (r = lt AND r = neq)) AND (NOT (r = lt AND r = no_rel))
	     AND (NOT (r = le AND r = gt)) AND (NOT (r = le AND r = ge))
	     AND (NOT (r = le AND r = eq)) AND (NOT (r = le AND r = neq))
	     AND (NOT (r = le AND r = no_rel)) AND (NOT (r = gt AND r = ge))
	     AND (NOT (r = gt AND r = eq)) AND (NOT (r = gt AND r = neq))
	     AND (NOT (r = gt AND r = no_rel)) AND (NOT (r = ge AND r = eq))
	     AND (NOT (r = ge AND r = neq)) AND (NOT (r = ge AND r = no_rel))
	     AND (NOT (r = eq AND r = neq)) AND (NOT (r = eq AND r = no_rel))
	     AND NOT (r = neq AND r = no_rel)
	
	% Coverage TCC generated (at line 55, column 2) for
	% COND r = lt -> "lt",
	%      r = le -> "le",
	%      r = gt -> "gt",
	%      r = ge -> "ge",
	%      r = eq -> "eq",
	%      r = neq -> "neq",
	%      r = no_rel -> "no_rel"
	% ENDCOND
	  % proved
	rel_op_type2string_TCC2: OBLIGATION
	FORALL (r: rel_op_type):
	         (r = lt) OR (r = le) OR (r = gt) OR (r = ge) OR (r = eq) OR (r = neq)
	     OR (r = no_rel)
	
	% Disjointness TCC generated (at line 79, column 2) for
	% COND dt = infusion_pump -> "infusion_pump",
	%      dt = vital_signs_device -> "vital_signs_device",
	%      dt = no_device -> "no_device"
	% ENDCOND
	  % proved
	device_type2string_TCC1: OBLIGATION
	FORALL (dt: device_type[maxrate, maxinfuse, maxtime]):
	    NOT (dt = infusion_pump[maxrate, maxinfuse, maxtime] AND
	          dt = vital_signs_device[maxrate, maxinfuse, maxtime])
	     AND
	     NOT (dt = infusion_pump[maxrate, maxinfuse, maxtime] AND
	           dt = no_device[maxrate, maxinfuse, maxtime])
	      AND
	      NOT (dt = vital_signs_device[maxrate, maxinfuse, maxtime] AND
	            dt = no_device[maxrate, maxinfuse, maxtime])
	
	% Coverage TCC generated (at line 79, column 2) for
	% COND dt = infusion_pump -> "infusion_pump",
	%      dt = vital_signs_device -> "vital_signs_device",
	%      dt = no_device -> "no_device"
	% ENDCOND
	  % proved
	device_type2string_TCC2: OBLIGATION
	FORALL (dt: device_type[maxrate, maxinfuse, maxtime]):
	    dt = infusion_pump[maxrate, maxinfuse, maxtime] OR
	     dt = vital_signs_device[maxrate, maxinfuse, maxtime] OR
	      dt = no_device[maxrate, maxinfuse, maxtime]
	
	% Disjointness TCC generated (at line 95, column 0) for
	% COND df = no_focus -> "no_focus",
	%      df = top_focus -> "top_focus",
	%      df = patient_focus -> "patient_focus",
	%      df = device_focus -> "device_focus"
	% ENDCOND
	  % proved
	disp_focus_type2string_TCC1: OBLIGATION
	FORALL (df: disp_focus_type):
	         (NOT (df = no_focus AND df = top_focus))
	     AND (NOT (df = no_focus AND df = patient_focus))
	     AND (NOT (df = no_focus AND df = device_focus))
	     AND (NOT (df = top_focus AND df = patient_focus))
	     AND (NOT (df = top_focus AND df = device_focus))
	     AND NOT (df = patient_focus AND df = device_focus)
	
	% Coverage TCC generated (at line 95, column 0) for
	% COND df = no_focus -> "no_focus",
	%      df = top_focus -> "top_focus",
	%      df = patient_focus -> "patient_focus",
	%      df = device_focus -> "device_focus"
	% ENDCOND
	  % proved
	disp_focus_type2string_TCC2: OBLIGATION
	FORALL (df: disp_focus_type):
	    df = no_focus OR df = top_focus OR df = patient_focus OR df = device_focus
	
	% Disjointness TCC generated (at line 104, column 3) for
	% COND m = off -> "off", m = pause -> "pause", m = infuse -> "infuse"
	% ENDCOND
	  % proved
	mode2string_TCC1: OBLIGATION
	FORALL (m: mode):
	    NOT (m = off AND m = pause) AND
	     NOT (m = off AND m = infuse) AND NOT (m = pause AND m = infuse)
	
	% Coverage TCC generated (at line 104, column 3) for
	% COND m = off -> "off", m = pause -> "pause", m = infuse -> "infuse"
	% ENDCOND
	  % proved
	mode2string_TCC2: OBLIGATION
	FORALL (m: mode): m = off OR m = pause OR m = infuse
	
	% Disjointness TCC generated (at line 112, column 3) for
	% COND dm = dblank -> "dblank",
	%      dm = mainmenu -> "mainmenu",
	%      dm = dvtbi -> "dvtbi",
	%      dm = drate -> "drate",
	%      dm = dtime -> "dtime",
	%      dm = dinfusing -> "dinfusing",
	%      dm = dalarm -> "dalarm",
	%      dm = dkvo -> "dkvo"
	% ENDCOND
	  % proved
	dispmode2string_TCC1: OBLIGATION
	FORALL (dm: dispmode):
	         (NOT (dm = dblank AND dm = mainmenu))
	     AND (NOT (dm = dblank AND dm = dvtbi))
	     AND (NOT (dm = dblank AND dm = drate))
	     AND (NOT (dm = dblank AND dm = dtime))
	     AND (NOT (dm = dblank AND dm = dinfusing))
	     AND (NOT (dm = dblank AND dm = dalarm))
	     AND (NOT (dm = dblank AND dm = dkvo))
	     AND (NOT (dm = mainmenu AND dm = dvtbi))
	     AND (NOT (dm = mainmenu AND dm = drate))
	     AND (NOT (dm = mainmenu AND dm = dtime))
	     AND (NOT (dm = mainmenu AND dm = dinfusing))
	     AND (NOT (dm = mainmenu AND dm = dalarm))
	     AND (NOT (dm = mainmenu AND dm = dkvo))
	     AND (NOT (dm = dvtbi AND dm = drate)) AND (NOT (dm = dvtbi AND dm = dtime))
	     AND (NOT (dm = dvtbi AND dm = dinfusing))
	     AND (NOT (dm = dvtbi AND dm = dalarm)) AND (NOT (dm = dvtbi AND dm = dkvo))
	     AND (NOT (dm = drate AND dm = dtime))
	     AND (NOT (dm = drate AND dm = dinfusing))
	     AND (NOT (dm = drate AND dm = dalarm)) AND (NOT (dm = drate AND dm = dkvo))
	     AND (NOT (dm = dtime AND dm = dinfusing))
	     AND (NOT (dm = dtime AND dm = dalarm)) AND (NOT (dm = dtime AND dm = dkvo))
	     AND (NOT (dm = dinfusing AND dm = dalarm))
	     AND (NOT (dm = dinfusing AND dm = dkvo))
	     AND NOT (dm = dalarm AND dm = dkvo)
	
	% Coverage TCC generated (at line 112, column 3) for
	% COND dm = dblank -> "dblank",
	%      dm = mainmenu -> "mainmenu",
	%      dm = dvtbi -> "dvtbi",
	%      dm = drate -> "drate",
	%      dm = dtime -> "dtime",
	%      dm = dinfusing -> "dinfusing",
	%      dm = dalarm -> "dalarm",
	%      dm = dkvo -> "dkvo"
	% ENDCOND
	  % proved
	dispmode2string_TCC2: OBLIGATION
	FORALL (dm: dispmode):
	         (dm = dblank) OR (dm = mainmenu) OR (dm = dvtbi) OR (dm = drate)
	     OR (dm = dtime) OR (dm = dinfusing) OR (dm = dalarm) OR (dm = dkvo)
	
	% Disjointness TCC generated (at line 125, column 3) for
	% COND c = open -> "open", c = closed -> "closed" ENDCOND
	  % proved
	clamp_state2string_TCC1: OBLIGATION
	FORALL (c: clamp_state): NOT (c = open AND c = closed)
	
	% Coverage TCC generated (at line 125, column 3) for
	% COND c = open -> "open", c = closed -> "closed" ENDCOND
	  % proved
	clamp_state2string_TCC2: OBLIGATION
	FORALL (c: clamp_state): c = open OR c = closed
	
	% Disjointness TCC generated (at line 132, column 3) for
	% COND p = rte -> "rte", p = tme -> "tme" ENDCOND
	  % proved
	priority_type2string_TCC1: OBLIGATION
	FORALL (p: priority_type): NOT (p = rte AND p = tme)
	
	% Coverage TCC generated (at line 132, column 3) for
	% COND p = rte -> "rte", p = tme -> "tme" ENDCOND
	  % proved
	priority_type2string_TCC2: OBLIGATION
	FORALL (p: priority_type): p = rte OR p = tme
	
	% Disjointness TCC generated (at line 139, column 0) for
	% COND m = no_action -> "no_action",
	%      m = delete -> "delete",
	%      m = cursor_up -> "cursor_up",
	%      m = cursor_down -> "cursor_down",
	%      m = select -> "select",
	%      m = enter -> "enter",
	%      m = top -> "top",
	%      m = main -> "main",
	%      m = patient -> "patient",
	%      m = device -> "device",
	%      m = device_filter -> "device_filter",
	%      m = region -> "region",
	%      m = rule -> "rule",
	%      m = constraint -> "constraint",
	%      m = edit -> "edit",
	%      m = clear -> "clear",
	%      m = display -> "display",
	%      m = parameter -> "parameter",
	%      m = action -> "action",
	%      m = relation -> "relation",
	%      m = num_value -> "num_value",
	%      m = enum_value -> "enum_value",
	%      m = escape -> "escape",
	%      m = pump -> "pump",
	%      m = vs_device -> "vs_device"
	% ENDCOND
	  % proved
	menu2string_TCC1: OBLIGATION
	FORALL (m: menu):
	         (NOT (m = no_action AND m = delete))
	     AND (NOT (m = no_action AND m = cursor_up))
	     AND (NOT (m = no_action AND m = cursor_down))
	     AND (NOT (m = no_action AND m = select))
	     AND (NOT (m = no_action AND m = enter))
	     AND (NOT (m = no_action AND m = top))
	     AND (NOT (m = no_action AND m = main))
	     AND (NOT (m = no_action AND m = patient))
	     AND (NOT (m = no_action AND m = device))
	     AND (NOT (m = no_action AND m = device_filter))
	     AND (NOT (m = no_action AND m = region))
	     AND (NOT (m = no_action AND m = rule))
	     AND (NOT (m = no_action AND m = constraint))
	     AND (NOT (m = no_action AND m = edit))
	     AND (NOT (m = no_action AND m = clear))
	     AND (NOT (m = no_action AND m = display))
	     AND (NOT (m = no_action AND m = parameter))
	     AND (NOT (m = no_action AND m = action))
	     AND (NOT (m = no_action AND m = relation))
	     AND (NOT (m = no_action AND m = num_value))
	     AND (NOT (m = no_action AND m = enum_value))
	     AND (NOT (m = no_action AND m = escape))
	     AND (NOT (m = no_action AND m = pump))
	     AND (NOT (m = no_action AND m = vs_device))
	     AND (NOT (m = delete AND m = cursor_up))
	     AND (NOT (m = delete AND m = cursor_down))
	     AND (NOT (m = delete AND m = select)) AND (NOT (m = delete AND m = enter))
	     AND (NOT (m = delete AND m = top)) AND (NOT (m = delete AND m = main))
	     AND (NOT (m = delete AND m = patient))
	     AND (NOT (m = delete AND m = device))
	     AND (NOT (m = delete AND m = device_filter))
	     AND (NOT (m = delete AND m = region)) AND (NOT (m = delete AND m = rule))
	     AND (NOT (m = delete AND m = constraint))
	     AND (NOT (m = delete AND m = edit)) AND (NOT (m = delete AND m = clear))
	     AND (NOT (m = delete AND m = display))
	     AND (NOT (m = delete AND m = parameter))
	     AND (NOT (m = delete AND m = action))
	     AND (NOT (m = delete AND m = relation))
	     AND (NOT (m = delete AND m = num_value))
	     AND (NOT (m = delete AND m = enum_value))
	     AND (NOT (m = delete AND m = escape)) AND (NOT (m = delete AND m = pump))
	     AND (NOT (m = delete AND m = vs_device))
	     AND (NOT (m = cursor_up AND m = cursor_down))
	     AND (NOT (m = cursor_up AND m = select))
	     AND (NOT (m = cursor_up AND m = enter))
	     AND (NOT (m = cursor_up AND m = top))
	     AND (NOT (m = cursor_up AND m = main))
	     AND (NOT (m = cursor_up AND m = patient))
	     AND (NOT (m = cursor_up AND m = device))
	     AND (NOT (m = cursor_up AND m = device_filter))
	     AND (NOT (m = cursor_up AND m = region))
	     AND (NOT (m = cursor_up AND m = rule))
	     AND (NOT (m = cursor_up AND m = constraint))
	     AND (NOT (m = cursor_up AND m = edit))
	     AND (NOT (m = cursor_up AND m = clear))
	     AND (NOT (m = cursor_up AND m = display))
	     AND (NOT (m = cursor_up AND m = parameter))
	     AND (NOT (m = cursor_up AND m = action))
	     AND (NOT (m = cursor_up AND m = relation))
	     AND (NOT (m = cursor_up AND m = num_value))
	     AND (NOT (m = cursor_up AND m = enum_value))
	     AND (NOT (m = cursor_up AND m = escape))
	     AND (NOT (m = cursor_up AND m = pump))
	     AND (NOT (m = cursor_up AND m = vs_device))
	     AND (NOT (m = cursor_down AND m = select))
	     AND (NOT (m = cursor_down AND m = enter))
	     AND (NOT (m = cursor_down AND m = top))
	     AND (NOT (m = cursor_down AND m = main))
	     AND (NOT (m = cursor_down AND m = patient))
	     AND (NOT (m = cursor_down AND m = device))
	     AND (NOT (m = cursor_down AND m = device_filter))
	     AND (NOT (m = cursor_down AND m = region))
	     AND (NOT (m = cursor_down AND m = rule))
	     AND (NOT (m = cursor_down AND m = constraint))
	     AND (NOT (m = cursor_down AND m = edit))
	     AND (NOT (m = cursor_down AND m = clear))
	     AND (NOT (m = cursor_down AND m = display))
	     AND (NOT (m = cursor_down AND m = parameter))
	     AND (NOT (m = cursor_down AND m = action))
	     AND (NOT (m = cursor_down AND m = relation))
	     AND (NOT (m = cursor_down AND m = num_value))
	     AND (NOT (m = cursor_down AND m = enum_value))
	     AND (NOT (m = cursor_down AND m = escape))
	     AND (NOT (m = cursor_down AND m = pump))
	     AND (NOT (m = cursor_down AND m = vs_device))
	     AND (NOT (m = select AND m = enter)) AND (NOT (m = select AND m = top))
	     AND (NOT (m = select AND m = main)) AND (NOT (m = select AND m = patient))
	     AND (NOT (m = select AND m = device))
	     AND (NOT (m = select AND m = device_filter))
	     AND (NOT (m = select AND m = region)) AND (NOT (m = select AND m = rule))
	     AND (NOT (m = select AND m = constraint))
	     AND (NOT (m = select AND m = edit)) AND (NOT (m = select AND m = clear))
	     AND (NOT (m = select AND m = display))
	     AND (NOT (m = select AND m = parameter))
	     AND (NOT (m = select AND m = action))
	     AND (NOT (m = select AND m = relation))
	     AND (NOT (m = select AND m = num_value))
	     AND (NOT (m = select AND m = enum_value))
	     AND (NOT (m = select AND m = escape)) AND (NOT (m = select AND m = pump))
	     AND (NOT (m = select AND m = vs_device)) AND (NOT (m = enter AND m = top))
	     AND (NOT (m = enter AND m = main)) AND (NOT (m = enter AND m = patient))
	     AND (NOT (m = enter AND m = device))
	     AND (NOT (m = enter AND m = device_filter))
	     AND (NOT (m = enter AND m = region)) AND (NOT (m = enter AND m = rule))
	     AND (NOT (m = enter AND m = constraint)) AND (NOT (m = enter AND m = edit))
	     AND (NOT (m = enter AND m = clear)) AND (NOT (m = enter AND m = display))
	     AND (NOT (m = enter AND m = parameter))
	     AND (NOT (m = enter AND m = action)) AND (NOT (m = enter AND m = relation))
	     AND (NOT (m = enter AND m = num_value))
	     AND (NOT (m = enter AND m = enum_value))
	     AND (NOT (m = enter AND m = escape)) AND (NOT (m = enter AND m = pump))
	     AND (NOT (m = enter AND m = vs_device)) AND (NOT (m = top AND m = main))
	     AND (NOT (m = top AND m = patient)) AND (NOT (m = top AND m = device))
	     AND (NOT (m = top AND m = device_filter))
	     AND (NOT (m = top AND m = region)) AND (NOT (m = top AND m = rule))
	     AND (NOT (m = top AND m = constraint)) AND (NOT (m = top AND m = edit))
	     AND (NOT (m = top AND m = clear)) AND (NOT (m = top AND m = display))
	     AND (NOT (m = top AND m = parameter)) AND (NOT (m = top AND m = action))
	     AND (NOT (m = top AND m = relation)) AND (NOT (m = top AND m = num_value))
	     AND (NOT (m = top AND m = enum_value)) AND (NOT (m = top AND m = escape))
	     AND (NOT (m = top AND m = pump)) AND (NOT (m = top AND m = vs_device))
	     AND (NOT (m = main AND m = patient)) AND (NOT (m = main AND m = device))
	     AND (NOT (m = main AND m = device_filter))
	     AND (NOT (m = main AND m = region)) AND (NOT (m = main AND m = rule))
	     AND (NOT (m = main AND m = constraint)) AND (NOT (m = main AND m = edit))
	     AND (NOT (m = main AND m = clear)) AND (NOT (m = main AND m = display))
	     AND (NOT (m = main AND m = parameter)) AND (NOT (m = main AND m = action))
	     AND (NOT (m = main AND m = relation))
	     AND (NOT (m = main AND m = num_value))
	     AND (NOT (m = main AND m = enum_value)) AND (NOT (m = main AND m = escape))
	     AND (NOT (m = main AND m = pump)) AND (NOT (m = main AND m = vs_device))
	     AND (NOT (m = patient AND m = device))
	     AND (NOT (m = patient AND m = device_filter))
	     AND (NOT (m = patient AND m = region)) AND (NOT (m = patient AND m = rule))
	     AND (NOT (m = patient AND m = constraint))
	     AND (NOT (m = patient AND m = edit)) AND (NOT (m = patient AND m = clear))
	     AND (NOT (m = patient AND m = display))
	     AND (NOT (m = patient AND m = parameter))
	     AND (NOT (m = patient AND m = action))
	     AND (NOT (m = patient AND m = relation))
	     AND (NOT (m = patient AND m = num_value))
	     AND (NOT (m = patient AND m = enum_value))
	     AND (NOT (m = patient AND m = escape)) AND (NOT (m = patient AND m = pump))
	     AND (NOT (m = patient AND m = vs_device))
	     AND (NOT (m = device AND m = device_filter))
	     AND (NOT (m = device AND m = region)) AND (NOT (m = device AND m = rule))
	     AND (NOT (m = device AND m = constraint))
	     AND (NOT (m = device AND m = edit)) AND (NOT (m = device AND m = clear))
	     AND (NOT (m = device AND m = display))
	     AND (NOT (m = device AND m = parameter))
	     AND (NOT (m = device AND m = action))
	     AND (NOT (m = device AND m = relation))
	     AND (NOT (m = device AND m = num_value))
	     AND (NOT (m = device AND m = enum_value))
	     AND (NOT (m = device AND m = escape)) AND (NOT (m = device AND m = pump))
	     AND (NOT (m = device AND m = vs_device))
	     AND (NOT (m = device_filter AND m = region))
	     AND (NOT (m = device_filter AND m = rule))
	     AND (NOT (m = device_filter AND m = constraint))
	     AND (NOT (m = device_filter AND m = edit))
	     AND (NOT (m = device_filter AND m = clear))
	     AND (NOT (m = device_filter AND m = display))
	     AND (NOT (m = device_filter AND m = parameter))
	     AND (NOT (m = device_filter AND m = action))
	     AND (NOT (m = device_filter AND m = relation))
	     AND (NOT (m = device_filter AND m = num_value))
	     AND (NOT (m = device_filter AND m = enum_value))
	     AND (NOT (m = device_filter AND m = escape))
	     AND (NOT (m = device_filter AND m = pump))
	     AND (NOT (m = device_filter AND m = vs_device))
	     AND (NOT (m = region AND m = rule))
	     AND (NOT (m = region AND m = constraint))
	     AND (NOT (m = region AND m = edit)) AND (NOT (m = region AND m = clear))
	     AND (NOT (m = region AND m = display))
	     AND (NOT (m = region AND m = parameter))
	     AND (NOT (m = region AND m = action))
	     AND (NOT (m = region AND m = relation))
	     AND (NOT (m = region AND m = num_value))
	     AND (NOT (m = region AND m = enum_value))
	     AND (NOT (m = region AND m = escape)) AND (NOT (m = region AND m = pump))
	     AND (NOT (m = region AND m = vs_device))
	     AND (NOT (m = rule AND m = constraint)) AND (NOT (m = rule AND m = edit))
	     AND (NOT (m = rule AND m = clear)) AND (NOT (m = rule AND m = display))
	     AND (NOT (m = rule AND m = parameter)) AND (NOT (m = rule AND m = action))
	     AND (NOT (m = rule AND m = relation))
	     AND (NOT (m = rule AND m = num_value))
	     AND (NOT (m = rule AND m = enum_value)) AND (NOT (m = rule AND m = escape))
	     AND (NOT (m = rule AND m = pump)) AND (NOT (m = rule AND m = vs_device))
	     AND (NOT (m = constraint AND m = edit))
	     AND (NOT (m = constraint AND m = clear))
	     AND (NOT (m = constraint AND m = display))
	     AND (NOT (m = constraint AND m = parameter))
	     AND (NOT (m = constraint AND m = action))
	     AND (NOT (m = constraint AND m = relation))
	     AND (NOT (m = constraint AND m = num_value))
	     AND (NOT (m = constraint AND m = enum_value))
	     AND (NOT (m = constraint AND m = escape))
	     AND (NOT (m = constraint AND m = pump))
	     AND (NOT (m = constraint AND m = vs_device))
	     AND (NOT (m = edit AND m = clear)) AND (NOT (m = edit AND m = display))
	     AND (NOT (m = edit AND m = parameter)) AND (NOT (m = edit AND m = action))
	     AND (NOT (m = edit AND m = relation))
	     AND (NOT (m = edit AND m = num_value))
	     AND (NOT (m = edit AND m = enum_value)) AND (NOT (m = edit AND m = escape))
	     AND (NOT (m = edit AND m = pump)) AND (NOT (m = edit AND m = vs_device))
	     AND (NOT (m = clear AND m = display))
	     AND (NOT (m = clear AND m = parameter))
	     AND (NOT (m = clear AND m = action)) AND (NOT (m = clear AND m = relation))
	     AND (NOT (m = clear AND m = num_value))
	     AND (NOT (m = clear AND m = enum_value))
	     AND (NOT (m = clear AND m = escape)) AND (NOT (m = clear AND m = pump))
	     AND (NOT (m = clear AND m = vs_device))
	     AND (NOT (m = display AND m = parameter))
	     AND (NOT (m = display AND m = action))
	     AND (NOT (m = display AND m = relation))
	     AND (NOT (m = display AND m = num_value))
	     AND (NOT (m = display AND m = enum_value))
	     AND (NOT (m = display AND m = escape)) AND (NOT (m = display AND m = pump))
	     AND (NOT (m = display AND m = vs_device))
	     AND (NOT (m = parameter AND m = action))
	     AND (NOT (m = parameter AND m = relation))
	     AND (NOT (m = parameter AND m = num_value))
	     AND (NOT (m = parameter AND m = enum_value))
	     AND (NOT (m = parameter AND m = escape))
	     AND (NOT (m = parameter AND m = pump))
	     AND (NOT (m = parameter AND m = vs_device))
	     AND (NOT (m = action AND m = relation))
	     AND (NOT (m = action AND m = num_value))
	     AND (NOT (m = action AND m = enum_value))
	     AND (NOT (m = action AND m = escape)) AND (NOT (m = action AND m = pump))
	     AND (NOT (m = action AND m = vs_device))
	     AND (NOT (m = relation AND m = num_value))
	     AND (NOT (m = relation AND m = enum_value))
	     AND (NOT (m = relation AND m = escape))
	     AND (NOT (m = relation AND m = pump))
	     AND (NOT (m = relation AND m = vs_device))
	     AND (NOT (m = num_value AND m = enum_value))
	     AND (NOT (m = num_value AND m = escape))
	     AND (NOT (m = num_value AND m = pump))
	     AND (NOT (m = num_value AND m = vs_device))
	     AND (NOT (m = enum_value AND m = escape))
	     AND (NOT (m = enum_value AND m = pump))
	     AND (NOT (m = enum_value AND m = vs_device))
	     AND (NOT (m = escape AND m = pump))
	     AND (NOT (m = escape AND m = vs_device))
	     AND NOT (m = pump AND m = vs_device)
	
	% Coverage TCC generated (at line 139, column 0) for
	% COND m = no_action -> "no_action",
	%      m = delete -> "delete",
	%      m = cursor_up -> "cursor_up",
	%      m = cursor_down -> "cursor_down",
	%      m = select -> "select",
	%      m = enter -> "enter",
	%      m = top -> "top",
	%      m = main -> "main",
	%      m = patient -> "patient",
	%      m = device -> "device",
	%      m = device_filter -> "device_filter",
	%      m = region -> "region",
	%      m = rule -> "rule",
	%      m = constraint -> "constraint",
	%      m = edit -> "edit",
	%      m = clear -> "clear",
	%      m = display -> "display",
	%      m = parameter -> "parameter",
	%      m = action -> "action",
	%      m = relation -> "relation",
	%      m = num_value -> "num_value",
	%      m = enum_value -> "enum_value",
	%      m = escape -> "escape",
	%      m = pump -> "pump",
	%      m = vs_device -> "vs_device"
	% ENDCOND
	  % proved
	menu2string_TCC2: OBLIGATION
	FORALL (m: menu):
	         (m = no_action) OR (m = delete) OR (m = cursor_up) OR (m = cursor_down)
	     OR (m = select) OR (m = enter) OR (m = top) OR (m = main) OR (m = patient)
	     OR (m = device) OR (m = device_filter) OR (m = region) OR (m = rule)
	     OR (m = constraint) OR (m = edit) OR (m = clear) OR (m = display)
	     OR (m = parameter) OR (m = action) OR (m = relation) OR (m = num_value)
	     OR (m = enum_value) OR (m = escape) OR (m = pump) OR (m = vs_device)
	
	% Disjointness TCC generated (at line 214, column 3) for
	% COND p = numeral -> "numeral",
	%      p = enumerated -> "enumerated",
	%      p = empty -> "empty"
	% ENDCOND
	  % proved
	value_type2string_TCC1: OBLIGATION
	FORALL (p: value_type):
	    NOT (p = numeral AND p = enumerated) AND
	     NOT (p = numeral AND p = empty) AND NOT (p = enumerated AND p = empty)
	
	% Coverage TCC generated (at line 214, column 3) for
	% COND p = numeral -> "numeral",
	%      p = enumerated -> "enumerated",
	%      p = empty -> "empty"
	% ENDCOND
	  % proved
	value_type2string_TCC2: OBLIGATION
	FORALL (p: value_type): p = numeral OR p = enumerated OR p = empty
	
	% Disjointness TCC generated (at line 222, column 3) for
	% COND a = rte -> "rte",
	%      a = vtb -> "vtb",
	%      a = tme -> "tme",
	%      a = dpm -> "dpm",
	%      a = mde -> "mde",
	%      a = num_er -> "num_er",
	%      a = enum_er -> "enum_er",
	%      a = hrte -> "hrte",
	%      a = blpl -> "blpl",
	%      a = blph -> "blph",
	%      a = sp -> "sp",
	%      a = rkrt -> "rkrt",
	%      a = ptmp -> "ptmp"
	% ENDCOND
	  % proved
	par2string_TCC1: OBLIGATION
	FORALL (a: par):
	         (NOT (a = rte AND a = vtb)) AND (NOT (a = rte AND a = tme))
	     AND (NOT (a = rte AND a = dpm)) AND (NOT (a = rte AND a = mde))
	     AND (NOT (a = rte AND a = num_er)) AND (NOT (a = rte AND a = enum_er))
	     AND (NOT (a = rte AND a = hrte)) AND (NOT (a = rte AND a = blpl))
	     AND (NOT (a = rte AND a = blph)) AND (NOT (a = rte AND a = sp))
	     AND (NOT (a = rte AND a = rkrt)) AND (NOT (a = rte AND a = ptmp))
	     AND (NOT (a = vtb AND a = tme)) AND (NOT (a = vtb AND a = dpm))
	     AND (NOT (a = vtb AND a = mde)) AND (NOT (a = vtb AND a = num_er))
	     AND (NOT (a = vtb AND a = enum_er)) AND (NOT (a = vtb AND a = hrte))
	     AND (NOT (a = vtb AND a = blpl)) AND (NOT (a = vtb AND a = blph))
	     AND (NOT (a = vtb AND a = sp)) AND (NOT (a = vtb AND a = rkrt))
	     AND (NOT (a = vtb AND a = ptmp)) AND (NOT (a = tme AND a = dpm))
	     AND (NOT (a = tme AND a = mde)) AND (NOT (a = tme AND a = num_er))
	     AND (NOT (a = tme AND a = enum_er)) AND (NOT (a = tme AND a = hrte))
	     AND (NOT (a = tme AND a = blpl)) AND (NOT (a = tme AND a = blph))
	     AND (NOT (a = tme AND a = sp)) AND (NOT (a = tme AND a = rkrt))
	     AND (NOT (a = tme AND a = ptmp)) AND (NOT (a = dpm AND a = mde))
	     AND (NOT (a = dpm AND a = num_er)) AND (NOT (a = dpm AND a = enum_er))
	     AND (NOT (a = dpm AND a = hrte)) AND (NOT (a = dpm AND a = blpl))
	     AND (NOT (a = dpm AND a = blph)) AND (NOT (a = dpm AND a = sp))
	     AND (NOT (a = dpm AND a = rkrt)) AND (NOT (a = dpm AND a = ptmp))
	     AND (NOT (a = mde AND a = num_er)) AND (NOT (a = mde AND a = enum_er))
	     AND (NOT (a = mde AND a = hrte)) AND (NOT (a = mde AND a = blpl))
	     AND (NOT (a = mde AND a = blph)) AND (NOT (a = mde AND a = sp))
	     AND (NOT (a = mde AND a = rkrt)) AND (NOT (a = mde AND a = ptmp))
	     AND (NOT (a = num_er AND a = enum_er)) AND (NOT (a = num_er AND a = hrte))
	     AND (NOT (a = num_er AND a = blpl)) AND (NOT (a = num_er AND a = blph))
	     AND (NOT (a = num_er AND a = sp)) AND (NOT (a = num_er AND a = rkrt))
	     AND (NOT (a = num_er AND a = ptmp)) AND (NOT (a = enum_er AND a = hrte))
	     AND (NOT (a = enum_er AND a = blpl)) AND (NOT (a = enum_er AND a = blph))
	     AND (NOT (a = enum_er AND a = sp)) AND (NOT (a = enum_er AND a = rkrt))
	     AND (NOT (a = enum_er AND a = ptmp)) AND (NOT (a = hrte AND a = blpl))
	     AND (NOT (a = hrte AND a = blph)) AND (NOT (a = hrte AND a = sp))
	     AND (NOT (a = hrte AND a = rkrt)) AND (NOT (a = hrte AND a = ptmp))
	     AND (NOT (a = blpl AND a = blph)) AND (NOT (a = blpl AND a = sp))
	     AND (NOT (a = blpl AND a = rkrt)) AND (NOT (a = blpl AND a = ptmp))
	     AND (NOT (a = blph AND a = sp)) AND (NOT (a = blph AND a = rkrt))
	     AND (NOT (a = blph AND a = ptmp)) AND (NOT (a = sp AND a = rkrt))
	     AND (NOT (a = sp AND a = ptmp)) AND NOT (a = rkrt AND a = ptmp)
	
	% Coverage TCC generated (at line 222, column 3) for
	% COND a = rte -> "rte",
	%      a = vtb -> "vtb",
	%      a = tme -> "tme",
	%      a = dpm -> "dpm",
	%      a = mde -> "mde",
	%      a = num_er -> "num_er",
	%      a = enum_er -> "enum_er",
	%      a = hrte -> "hrte",
	%      a = blpl -> "blpl",
	%      a = blph -> "blph",
	%      a = sp -> "sp",
	%      a = rkrt -> "rkrt",
	%      a = ptmp -> "ptmp"
	% ENDCOND
	  % proved
	par2string_TCC2: OBLIGATION
	FORALL (a: par):
	         (a = rte) OR (a = vtb) OR (a = tme) OR (a = dpm) OR (a = mde)
	     OR (a = num_er) OR (a = enum_er) OR (a = hrte) OR (a = blpl) OR (a = blph)
	     OR (a = sp) OR (a = rkrt) OR (a = ptmp)
	
	% Disjointness TCC generated (at line 260, column 3) for
	% COND e = xoff -> "xoff",
	%      e = xpause -> "xpause",
	%      e = xinfuse -> "xinfuse",
	%      e = xdblank -> "xdblank",
	%      e = xmainmenu -> "xmainmenu",
	%      e = xdvtbi -> "xdvtbi",
	%      e = xdrate -> "xdrate",
	%      e = xdtime -> "xdtime",
	%      e = xdinfusing -> "xdinfusing",
	%      e = xdalarm -> "xdalarm",
	%      e = xdkvo -> "xdkvo",
	%      e = xopen -> "xopen",
	%      e = xclosed -> "xclosed",
	%      e = xrte -> "xrte",
	%      e = xtme -> "xtme",
	%      e = xisconnected -> "xisconnected",
	%      e = xactive -> "xactive",
	%      e = xnumeral -> "xnumeral",
	%      e = xenumerated -> "xenumerated",
	%      e = xnilval -> "xnilval",
	%      e = xalarm -> "xalarm",
	%      e = xok -> "xok",
	%      e = xnovalue -> "xnovalue"
	% ENDCOND
	  % proved
	enum2string_TCC1: OBLIGATION
	FORALL (e: enum):
	         (NOT (e = xoff AND e = xpause)) AND (NOT (e = xoff AND e = xinfuse))
	     AND (NOT (e = xoff AND e = xdblank)) AND (NOT (e = xoff AND e = xmainmenu))
	     AND (NOT (e = xoff AND e = xdvtbi)) AND (NOT (e = xoff AND e = xdrate))
	     AND (NOT (e = xoff AND e = xdtime)) AND (NOT (e = xoff AND e = xdinfusing))
	     AND (NOT (e = xoff AND e = xdalarm)) AND (NOT (e = xoff AND e = xdkvo))
	     AND (NOT (e = xoff AND e = xopen)) AND (NOT (e = xoff AND e = xclosed))
	     AND (NOT (e = xoff AND e = xrte)) AND (NOT (e = xoff AND e = xtme))
	     AND (NOT (e = xoff AND e = xisconnected))
	     AND (NOT (e = xoff AND e = xactive)) AND (NOT (e = xoff AND e = xnumeral))
	     AND (NOT (e = xoff AND e = xenumerated))
	     AND (NOT (e = xoff AND e = xnilval)) AND (NOT (e = xoff AND e = xalarm))
	     AND (NOT (e = xoff AND e = xok)) AND (NOT (e = xoff AND e = xnovalue))
	     AND (NOT (e = xpause AND e = xinfuse))
	     AND (NOT (e = xpause AND e = xdblank))
	     AND (NOT (e = xpause AND e = xmainmenu))
	     AND (NOT (e = xpause AND e = xdvtbi)) AND (NOT (e = xpause AND e = xdrate))
	     AND (NOT (e = xpause AND e = xdtime))
	     AND (NOT (e = xpause AND e = xdinfusing))
	     AND (NOT (e = xpause AND e = xdalarm)) AND (NOT (e = xpause AND e = xdkvo))
	     AND (NOT (e = xpause AND e = xopen)) AND (NOT (e = xpause AND e = xclosed))
	     AND (NOT (e = xpause AND e = xrte)) AND (NOT (e = xpause AND e = xtme))
	     AND (NOT (e = xpause AND e = xisconnected))
	     AND (NOT (e = xpause AND e = xactive))
	     AND (NOT (e = xpause AND e = xnumeral))
	     AND (NOT (e = xpause AND e = xenumerated))
	     AND (NOT (e = xpause AND e = xnilval))
	     AND (NOT (e = xpause AND e = xalarm)) AND (NOT (e = xpause AND e = xok))
	     AND (NOT (e = xpause AND e = xnovalue))
	     AND (NOT (e = xinfuse AND e = xdblank))
	     AND (NOT (e = xinfuse AND e = xmainmenu))
	     AND (NOT (e = xinfuse AND e = xdvtbi))
	     AND (NOT (e = xinfuse AND e = xdrate))
	     AND (NOT (e = xinfuse AND e = xdtime))
	     AND (NOT (e = xinfuse AND e = xdinfusing))
	     AND (NOT (e = xinfuse AND e = xdalarm))
	     AND (NOT (e = xinfuse AND e = xdkvo)) AND (NOT (e = xinfuse AND e = xopen))
	     AND (NOT (e = xinfuse AND e = xclosed))
	     AND (NOT (e = xinfuse AND e = xrte)) AND (NOT (e = xinfuse AND e = xtme))
	     AND (NOT (e = xinfuse AND e = xisconnected))
	     AND (NOT (e = xinfuse AND e = xactive))
	     AND (NOT (e = xinfuse AND e = xnumeral))
	     AND (NOT (e = xinfuse AND e = xenumerated))
	     AND (NOT (e = xinfuse AND e = xnilval))
	     AND (NOT (e = xinfuse AND e = xalarm)) AND (NOT (e = xinfuse AND e = xok))
	     AND (NOT (e = xinfuse AND e = xnovalue))
	     AND (NOT (e = xdblank AND e = xmainmenu))
	     AND (NOT (e = xdblank AND e = xdvtbi))
	     AND (NOT (e = xdblank AND e = xdrate))
	     AND (NOT (e = xdblank AND e = xdtime))
	     AND (NOT (e = xdblank AND e = xdinfusing))
	     AND (NOT (e = xdblank AND e = xdalarm))
	     AND (NOT (e = xdblank AND e = xdkvo)) AND (NOT (e = xdblank AND e = xopen))
	     AND (NOT (e = xdblank AND e = xclosed))
	     AND (NOT (e = xdblank AND e = xrte)) AND (NOT (e = xdblank AND e = xtme))
	     AND (NOT (e = xdblank AND e = xisconnected))
	     AND (NOT (e = xdblank AND e = xactive))
	     AND (NOT (e = xdblank AND e = xnumeral))
	     AND (NOT (e = xdblank AND e = xenumerated))
	     AND (NOT (e = xdblank AND e = xnilval))
	     AND (NOT (e = xdblank AND e = xalarm)) AND (NOT (e = xdblank AND e = xok))
	     AND (NOT (e = xdblank AND e = xnovalue))
	     AND (NOT (e = xmainmenu AND e = xdvtbi))
	     AND (NOT (e = xmainmenu AND e = xdrate))
	     AND (NOT (e = xmainmenu AND e = xdtime))
	     AND (NOT (e = xmainmenu AND e = xdinfusing))
	     AND (NOT (e = xmainmenu AND e = xdalarm))
	     AND (NOT (e = xmainmenu AND e = xdkvo))
	     AND (NOT (e = xmainmenu AND e = xopen))
	     AND (NOT (e = xmainmenu AND e = xclosed))
	     AND (NOT (e = xmainmenu AND e = xrte))
	     AND (NOT (e = xmainmenu AND e = xtme))
	     AND (NOT (e = xmainmenu AND e = xisconnected))
	     AND (NOT (e = xmainmenu AND e = xactive))
	     AND (NOT (e = xmainmenu AND e = xnumeral))
	     AND (NOT (e = xmainmenu AND e = xenumerated))
	     AND (NOT (e = xmainmenu AND e = xnilval))
	     AND (NOT (e = xmainmenu AND e = xalarm))
	     AND (NOT (e = xmainmenu AND e = xok))
	     AND (NOT (e = xmainmenu AND e = xnovalue))
	     AND (NOT (e = xdvtbi AND e = xdrate)) AND (NOT (e = xdvtbi AND e = xdtime))
	     AND (NOT (e = xdvtbi AND e = xdinfusing))
	     AND (NOT (e = xdvtbi AND e = xdalarm)) AND (NOT (e = xdvtbi AND e = xdkvo))
	     AND (NOT (e = xdvtbi AND e = xopen)) AND (NOT (e = xdvtbi AND e = xclosed))
	     AND (NOT (e = xdvtbi AND e = xrte)) AND (NOT (e = xdvtbi AND e = xtme))
	     AND (NOT (e = xdvtbi AND e = xisconnected))
	     AND (NOT (e = xdvtbi AND e = xactive))
	     AND (NOT (e = xdvtbi AND e = xnumeral))
	     AND (NOT (e = xdvtbi AND e = xenumerated))
	     AND (NOT (e = xdvtbi AND e = xnilval))
	     AND (NOT (e = xdvtbi AND e = xalarm)) AND (NOT (e = xdvtbi AND e = xok))
	     AND (NOT (e = xdvtbi AND e = xnovalue))
	     AND (NOT (e = xdrate AND e = xdtime))
	     AND (NOT (e = xdrate AND e = xdinfusing))
	     AND (NOT (e = xdrate AND e = xdalarm)) AND (NOT (e = xdrate AND e = xdkvo))
	     AND (NOT (e = xdrate AND e = xopen)) AND (NOT (e = xdrate AND e = xclosed))
	     AND (NOT (e = xdrate AND e = xrte)) AND (NOT (e = xdrate AND e = xtme))
	     AND (NOT (e = xdrate AND e = xisconnected))
	     AND (NOT (e = xdrate AND e = xactive))
	     AND (NOT (e = xdrate AND e = xnumeral))
	     AND (NOT (e = xdrate AND e = xenumerated))
	     AND (NOT (e = xdrate AND e = xnilval))
	     AND (NOT (e = xdrate AND e = xalarm)) AND (NOT (e = xdrate AND e = xok))
	     AND (NOT (e = xdrate AND e = xnovalue))
	     AND (NOT (e = xdtime AND e = xdinfusing))
	     AND (NOT (e = xdtime AND e = xdalarm)) AND (NOT (e = xdtime AND e = xdkvo))
	     AND (NOT (e = xdtime AND e = xopen)) AND (NOT (e = xdtime AND e = xclosed))
	     AND (NOT (e = xdtime AND e = xrte)) AND (NOT (e = xdtime AND e = xtme))
	     AND (NOT (e = xdtime AND e = xisconnected))
	     AND (NOT (e = xdtime AND e = xactive))
	     AND (NOT (e = xdtime AND e = xnumeral))
	     AND (NOT (e = xdtime AND e = xenumerated))
	     AND (NOT (e = xdtime AND e = xnilval))
	     AND (NOT (e = xdtime AND e = xalarm)) AND (NOT (e = xdtime AND e = xok))
	     AND (NOT (e = xdtime AND e = xnovalue))
	     AND (NOT (e = xdinfusing AND e = xdalarm))
	     AND (NOT (e = xdinfusing AND e = xdkvo))
	     AND (NOT (e = xdinfusing AND e = xopen))
	     AND (NOT (e = xdinfusing AND e = xclosed))
	     AND (NOT (e = xdinfusing AND e = xrte))
	     AND (NOT (e = xdinfusing AND e = xtme))
	     AND (NOT (e = xdinfusing AND e = xisconnected))
	     AND (NOT (e = xdinfusing AND e = xactive))
	     AND (NOT (e = xdinfusing AND e = xnumeral))
	     AND (NOT (e = xdinfusing AND e = xenumerated))
	     AND (NOT (e = xdinfusing AND e = xnilval))
	     AND (NOT (e = xdinfusing AND e = xalarm))
	     AND (NOT (e = xdinfusing AND e = xok))
	     AND (NOT (e = xdinfusing AND e = xnovalue))
	     AND (NOT (e = xdalarm AND e = xdkvo)) AND (NOT (e = xdalarm AND e = xopen))
	     AND (NOT (e = xdalarm AND e = xclosed))
	     AND (NOT (e = xdalarm AND e = xrte)) AND (NOT (e = xdalarm AND e = xtme))
	     AND (NOT (e = xdalarm AND e = xisconnected))
	     AND (NOT (e = xdalarm AND e = xactive))
	     AND (NOT (e = xdalarm AND e = xnumeral))
	     AND (NOT (e = xdalarm AND e = xenumerated))
	     AND (NOT (e = xdalarm AND e = xnilval))
	     AND (NOT (e = xdalarm AND e = xalarm)) AND (NOT (e = xdalarm AND e = xok))
	     AND (NOT (e = xdalarm AND e = xnovalue))
	     AND (NOT (e = xdkvo AND e = xopen)) AND (NOT (e = xdkvo AND e = xclosed))
	     AND (NOT (e = xdkvo AND e = xrte)) AND (NOT (e = xdkvo AND e = xtme))
	     AND (NOT (e = xdkvo AND e = xisconnected))
	     AND (NOT (e = xdkvo AND e = xactive))
	     AND (NOT (e = xdkvo AND e = xnumeral))
	     AND (NOT (e = xdkvo AND e = xenumerated))
	     AND (NOT (e = xdkvo AND e = xnilval)) AND (NOT (e = xdkvo AND e = xalarm))
	     AND (NOT (e = xdkvo AND e = xok)) AND (NOT (e = xdkvo AND e = xnovalue))
	     AND (NOT (e = xopen AND e = xclosed)) AND (NOT (e = xopen AND e = xrte))
	     AND (NOT (e = xopen AND e = xtme))
	     AND (NOT (e = xopen AND e = xisconnected))
	     AND (NOT (e = xopen AND e = xactive))
	     AND (NOT (e = xopen AND e = xnumeral))
	     AND (NOT (e = xopen AND e = xenumerated))
	     AND (NOT (e = xopen AND e = xnilval)) AND (NOT (e = xopen AND e = xalarm))
	     AND (NOT (e = xopen AND e = xok)) AND (NOT (e = xopen AND e = xnovalue))
	     AND (NOT (e = xclosed AND e = xrte)) AND (NOT (e = xclosed AND e = xtme))
	     AND (NOT (e = xclosed AND e = xisconnected))
	     AND (NOT (e = xclosed AND e = xactive))
	     AND (NOT (e = xclosed AND e = xnumeral))
	     AND (NOT (e = xclosed AND e = xenumerated))
	     AND (NOT (e = xclosed AND e = xnilval))
	     AND (NOT (e = xclosed AND e = xalarm)) AND (NOT (e = xclosed AND e = xok))
	     AND (NOT (e = xclosed AND e = xnovalue)) AND (NOT (e = xrte AND e = xtme))
	     AND (NOT (e = xrte AND e = xisconnected))
	     AND (NOT (e = xrte AND e = xactive)) AND (NOT (e = xrte AND e = xnumeral))
	     AND (NOT (e = xrte AND e = xenumerated))
	     AND (NOT (e = xrte AND e = xnilval)) AND (NOT (e = xrte AND e = xalarm))
	     AND (NOT (e = xrte AND e = xok)) AND (NOT (e = xrte AND e = xnovalue))
	     AND (NOT (e = xtme AND e = xisconnected))
	     AND (NOT (e = xtme AND e = xactive)) AND (NOT (e = xtme AND e = xnumeral))
	     AND (NOT (e = xtme AND e = xenumerated))
	     AND (NOT (e = xtme AND e = xnilval)) AND (NOT (e = xtme AND e = xalarm))
	     AND (NOT (e = xtme AND e = xok)) AND (NOT (e = xtme AND e = xnovalue))
	     AND (NOT (e = xisconnected AND e = xactive))
	     AND (NOT (e = xisconnected AND e = xnumeral))
	     AND (NOT (e = xisconnected AND e = xenumerated))
	     AND (NOT (e = xisconnected AND e = xnilval))
	     AND (NOT (e = xisconnected AND e = xalarm))
	     AND (NOT (e = xisconnected AND e = xok))
	     AND (NOT (e = xisconnected AND e = xnovalue))
	     AND (NOT (e = xactive AND e = xnumeral))
	     AND (NOT (e = xactive AND e = xenumerated))
	     AND (NOT (e = xactive AND e = xnilval))
	     AND (NOT (e = xactive AND e = xalarm)) AND (NOT (e = xactive AND e = xok))
	     AND (NOT (e = xactive AND e = xnovalue))
	     AND (NOT (e = xnumeral AND e = xenumerated))
	     AND (NOT (e = xnumeral AND e = xnilval))
	     AND (NOT (e = xnumeral AND e = xalarm))
	     AND (NOT (e = xnumeral AND e = xok))
	     AND (NOT (e = xnumeral AND e = xnovalue))
	     AND (NOT (e = xenumerated AND e = xnilval))
	     AND (NOT (e = xenumerated AND e = xalarm))
	     AND (NOT (e = xenumerated AND e = xok))
	     AND (NOT (e = xenumerated AND e = xnovalue))
	     AND (NOT (e = xnilval AND e = xalarm)) AND (NOT (e = xnilval AND e = xok))
	     AND (NOT (e = xnilval AND e = xnovalue)) AND (NOT (e = xalarm AND e = xok))
	     AND (NOT (e = xalarm AND e = xnovalue)) AND NOT (e = xok AND e = xnovalue)
	
	% Coverage TCC generated (at line 260, column 3) for
	% COND e = xoff -> "xoff",
	%      e = xpause -> "xpause",
	%      e = xinfuse -> "xinfuse",
	%      e = xdblank -> "xdblank",
	%      e = xmainmenu -> "xmainmenu",
	%      e = xdvtbi -> "xdvtbi",
	%      e = xdrate -> "xdrate",
	%      e = xdtime -> "xdtime",
	%      e = xdinfusing -> "xdinfusing",
	%      e = xdalarm -> "xdalarm",
	%      e = xdkvo -> "xdkvo",
	%      e = xopen -> "xopen",
	%      e = xclosed -> "xclosed",
	%      e = xrte -> "xrte",
	%      e = xtme -> "xtme",
	%      e = xisconnected -> "xisconnected",
	%      e = xactive -> "xactive",
	%      e = xnumeral -> "xnumeral",
	%      e = xenumerated -> "xenumerated",
	%      e = xnilval -> "xnilval",
	%      e = xalarm -> "xalarm",
	%      e = xok -> "xok",
	%      e = xnovalue -> "xnovalue"
	% ENDCOND
	  % proved
	enum2string_TCC2: OBLIGATION
	FORALL (e: enum):
	         (e = xoff) OR (e = xpause) OR (e = xinfuse) OR (e = xdblank)
	     OR (e = xmainmenu) OR (e = xdvtbi) OR (e = xdrate) OR (e = xdtime)
	     OR (e = xdinfusing) OR (e = xdalarm) OR (e = xdkvo) OR (e = xopen)
	     OR (e = xclosed) OR (e = xrte) OR (e = xtme) OR (e = xisconnected)
	     OR (e = xactive) OR (e = xnumeral) OR (e = xenumerated) OR (e = xnilval)
	     OR (e = xalarm) OR (e = xok) OR (e = xnovalue)
	
	% Disjointness TCC generated (at line 316, column 0) for
	% COND mh = nomsg -> "nomsg",
	%      mh = tmmsg -> "tmmsg",
	%      mh = pmmsg -> "pmmsg",
	%      mh = mmmsg -> "mmmsg",
	%      mh = updmsg -> "updmsg",
	%      mh = actmsg -> "actmsg",
	%      mh = cnstmsg -> "cnstmsg"
	% ENDCOND
	  % proved
	msghdr2string_TCC1: OBLIGATION
	FORALL (mh: msg_hdr_type[maxrate, maxinfuse, maxtime]):
	         (NOT (mh = nomsg[maxrate, maxinfuse, maxtime] AND
	                mh = tmmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = nomsg[maxrate, maxinfuse, maxtime] AND
	                mh = pmmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = nomsg[maxrate, maxinfuse, maxtime] AND
	                mh = mmmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = nomsg[maxrate, maxinfuse, maxtime] AND
	                mh = updmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = nomsg[maxrate, maxinfuse, maxtime] AND
	                mh = actmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = nomsg[maxrate, maxinfuse, maxtime] AND
	                mh = cnstmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = tmmsg[maxrate, maxinfuse, maxtime] AND
	                mh = pmmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = tmmsg[maxrate, maxinfuse, maxtime] AND
	                mh = mmmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = tmmsg[maxrate, maxinfuse, maxtime] AND
	                mh = updmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = tmmsg[maxrate, maxinfuse, maxtime] AND
	                mh = actmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = tmmsg[maxrate, maxinfuse, maxtime] AND
	                mh = cnstmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = pmmsg[maxrate, maxinfuse, maxtime] AND
	                mh = mmmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = pmmsg[maxrate, maxinfuse, maxtime] AND
	                mh = updmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = pmmsg[maxrate, maxinfuse, maxtime] AND
	                mh = actmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = pmmsg[maxrate, maxinfuse, maxtime] AND
	                mh = cnstmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = mmmsg[maxrate, maxinfuse, maxtime] AND
	                mh = updmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = mmmsg[maxrate, maxinfuse, maxtime] AND
	                mh = actmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = mmmsg[maxrate, maxinfuse, maxtime] AND
	                mh = cnstmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = updmsg[maxrate, maxinfuse, maxtime] AND
	                mh = actmsg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (mh = updmsg[maxrate, maxinfuse, maxtime] AND
	                mh = cnstmsg[maxrate, maxinfuse, maxtime]))
	     AND NOT (mh = actmsg[maxrate, maxinfuse, maxtime] AND
	               mh = cnstmsg[maxrate, maxinfuse, maxtime])
	
	% Coverage TCC generated (at line 316, column 0) for
	% COND mh = nomsg -> "nomsg",
	%      mh = tmmsg -> "tmmsg",
	%      mh = pmmsg -> "pmmsg",
	%      mh = mmmsg -> "mmmsg",
	%      mh = updmsg -> "updmsg",
	%      mh = actmsg -> "actmsg",
	%      mh = cnstmsg -> "cnstmsg"
	% ENDCOND
	  % proved
	msghdr2string_TCC2: OBLIGATION
	FORALL (mh: msg_hdr_type[maxrate, maxinfuse, maxtime]):
	         (mh = nomsg[maxrate, maxinfuse, maxtime])
	     OR (mh = tmmsg[maxrate, maxinfuse, maxtime])
	     OR (mh = pmmsg[maxrate, maxinfuse, maxtime])
	     OR (mh = mmmsg[maxrate, maxinfuse, maxtime])
	     OR (mh = updmsg[maxrate, maxinfuse, maxtime])
	     OR (mh = actmsg[maxrate, maxinfuse, maxtime])
	     OR (mh = cnstmsg[maxrate, maxinfuse, maxtime])
	
	% Disjointness TCC generated (at line 328, column 0) for
	% COND bs = full -> "full",
	%      bs = empty -> "empty",
	%      bs = functioning -> "functioning"
	% ENDCOND
	  % proved
	b_status2string_TCC1: OBLIGATION
	FORALL (bs: b_status[maxrate, maxinfuse, maxtime]):
	    NOT (bs = full[maxrate, maxinfuse, maxtime] AND
	          bs = empty[maxrate, maxinfuse, maxtime])
	     AND
	     NOT (bs = full[maxrate, maxinfuse, maxtime] AND
	           bs = functioning[maxrate, maxinfuse, maxtime])
	      AND
	      NOT (bs = empty[maxrate, maxinfuse, maxtime] AND
	            bs = functioning[maxrate, maxinfuse, maxtime])
	
	% Coverage TCC generated (at line 328, column 0) for
	% COND bs = full -> "full",
	%      bs = empty -> "empty",
	%      bs = functioning -> "functioning"
	% ENDCOND
	  % proved
	b_status2string_TCC2: OBLIGATION
	FORALL (bs: b_status[maxrate, maxinfuse, maxtime]):
	    bs = full[maxrate, maxinfuse, maxtime] OR
	     bs = empty[maxrate, maxinfuse, maxtime] OR
	      bs = functioning[maxrate, maxinfuse, maxtime]
	
	% Disjointness TCC generated (at line 336, column 0) for
	% COND ne = clear -> "clear",
	%      ne = not_connected -> "not_connected",
	%      ne = no_msg -> "no_msg",
	%      ne = empty_q -> "empty_q",
	%      ne = full_q -> "full_q",
	%      ne = spurious_action -> "spurious_action"
	% ENDCOND
	  % proved
	nw_error_type2string_TCC1: OBLIGATION
	FORALL (ne: nw_error_type[maxrate, maxinfuse, maxtime]):
	         (NOT (ne = clear[maxrate, maxinfuse, maxtime] AND
	                ne = not_connected[maxrate, maxinfuse, maxtime]))
	     AND (NOT (ne = clear[maxrate, maxinfuse, maxtime] AND
	                ne = no_msg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (ne = clear[maxrate, maxinfuse, maxtime] AND
	                ne = empty_q[maxrate, maxinfuse, maxtime]))
	     AND (NOT (ne = clear[maxrate, maxinfuse, maxtime] AND
	                ne = full_q[maxrate, maxinfuse, maxtime]))
	     AND (NOT (ne = clear[maxrate, maxinfuse, maxtime] AND
	                ne = spurious_action[maxrate, maxinfuse, maxtime]))
	     AND (NOT (ne = not_connected[maxrate, maxinfuse, maxtime] AND
	                ne = no_msg[maxrate, maxinfuse, maxtime]))
	     AND (NOT (ne = not_connected[maxrate, maxinfuse, maxtime] AND
	                ne = empty_q[maxrate, maxinfuse, maxtime]))
	     AND (NOT (ne = not_connected[maxrate, maxinfuse, maxtime] AND
	                ne = full_q[maxrate, maxinfuse, maxtime]))
	     AND (NOT (ne = not_connected[maxrate, maxinfuse, maxtime] AND
	                ne = spurious_action[maxrate, maxinfuse, maxtime]))
	     AND (NOT (ne = no_msg[maxrate, maxinfuse, maxtime] AND
	                ne = empty_q[maxrate, maxinfuse, maxtime]))
	     AND (NOT (ne = no_msg[maxrate, maxinfuse, maxtime] AND
	                ne = full_q[maxrate, maxinfuse, maxtime]))
	     AND (NOT (ne = no_msg[maxrate, maxinfuse, maxtime] AND
	                ne = spurious_action[maxrate, maxinfuse, maxtime]))
	     AND (NOT (ne = empty_q[maxrate, maxinfuse, maxtime] AND
	                ne = full_q[maxrate, maxinfuse, maxtime]))
	     AND (NOT (ne = empty_q[maxrate, maxinfuse, maxtime] AND
	                ne = spurious_action[maxrate, maxinfuse, maxtime]))
	     AND NOT (ne = full_q[maxrate, maxinfuse, maxtime] AND
	               ne = spurious_action[maxrate, maxinfuse, maxtime])
	
	% Coverage TCC generated (at line 336, column 0) for
	% COND ne = clear -> "clear",
	%      ne = not_connected -> "not_connected",
	%      ne = no_msg -> "no_msg",
	%      ne = empty_q -> "empty_q",
	%      ne = full_q -> "full_q",
	%      ne = spurious_action -> "spurious_action"
	% ENDCOND
	  % proved
	nw_error_type2string_TCC2: OBLIGATION
	FORALL (ne: nw_error_type[maxrate, maxinfuse, maxtime]):
	         (ne = clear[maxrate, maxinfuse, maxtime])
	     OR (ne = not_connected[maxrate, maxinfuse, maxtime])
	     OR (ne = no_msg[maxrate, maxinfuse, maxtime])
	     OR (ne = empty_q[maxrate, maxinfuse, maxtime])
	     OR (ne = full_q[maxrate, maxinfuse, maxtime])
	     OR (ne = spurious_action[maxrate, maxinfuse, maxtime])
	
	% Subtype TCC generated (at line 435, column 20) for  n
	% expected type  upto(nlimit)
	  % proved
	node_printer_bool_TCC1: OBLIGATION
	FORALL (n: node[maxrate, maxinfuse, maxtime]): n = 0 IMPLIES n <= nlimit
	
	% Subtype TCC generated (at line 436, column 20) for  n
	% expected type  upto(nlimit)
	  % proved
	node_printer_bool_TCC2: OBLIGATION
	FORALL (n: node[maxrate, maxinfuse, maxtime]): n > 0 IMPLIES n <= nlimit
	
	% Subtype TCC generated (at line 436, column 70) for  n - 1
	% expected type  node[maxrate, maxinfuse, maxtime]
	  % proved
	node_printer_bool_TCC3: OBLIGATION
	FORALL (l: [upto(nlimit) -> bool], n: node[maxrate, maxinfuse, maxtime]):
	    n > 0 AND l(n) IMPLIES n - 1 >= 0 AND n - 1 <= nlimit
	
	% Termination TCC generated (at line 436, column 49) for
	% node_printer_bool(l, n - 1)
	  % proved
	node_printer_bool_TCC4: OBLIGATION
	FORALL (l: [upto(nlimit) -> bool], n: node[maxrate, maxinfuse, maxtime]):
	    n > 0 AND l(n) IMPLIES n - 1 < n
	
	% Disjointness TCC generated (at line 434, column 4) for
	% COND n = 0 ->
	%        IF l(n) THEN concat(concat(" node(", real2str(n)), ")")
	%        ELSE ""
	%        ENDIF,
	%      n > 0 ->
	%        IF l(n)
	%          THEN concat(concat(concat(" node(", real2str(n)), ")"),
	%                      node_printer_bool(l, n - 1))
	%        ELSE node_printer_bool(l, n - 1)
	%        ENDIF
	% ENDCOND
	  % proved
	node_printer_bool_TCC5: OBLIGATION
	FORALL (n: node[maxrate, maxinfuse, maxtime]): NOT (n = 0 AND n > 0)
	
	% Coverage TCC generated (at line 434, column 4) for
	% COND n = 0 ->
	%        IF l(n) THEN concat(concat(" node(", real2str(n)), ")")
	%        ELSE ""
	%        ENDIF,
	%      n > 0 ->
	%        IF l(n)
	%          THEN concat(concat(concat(" node(", real2str(n)), ")"),
	%                      node_printer_bool(l, n - 1))
	%        ELSE node_printer_bool(l, n - 1)
	%        ENDIF
	% ENDCOND
	  % proved
	node_printer_bool_TCC6: OBLIGATION
	FORALL (n: node[maxrate, maxinfuse, maxtime]): n = 0 OR n > 0
	
	% Subtype TCC generated (at line 443, column 20) for  d
	% expected type  upto(dlimit)
	  % proved
	device_printer_bool_TCC1: OBLIGATION
	FORALL (d: device[maxrate, maxinfuse, maxtime]): d = 0 IMPLIES d <= dlimit
	
	% Subtype TCC generated (at line 444, column 20) for  d
	% expected type  upto(dlimit)
	  % proved
	device_printer_bool_TCC2: OBLIGATION
	FORALL (d: device[maxrate, maxinfuse, maxtime]): d > 0 IMPLIES d <= dlimit
	
	% Subtype TCC generated (at line 444, column 74) for  d - 1
	% expected type  device[maxrate, maxinfuse, maxtime]
	  % proved
	device_printer_bool_TCC3: OBLIGATION
	FORALL (l: [upto(dlimit) -> bool], d: device[maxrate, maxinfuse, maxtime]):
	    d > 0 AND l(d) IMPLIES d - 1 >= 0 AND d - 1 <= nlimit
	
	% Termination TCC generated (at line 444, column 51) for
	% device_printer_bool(l, d - 1)
	  % proved
	device_printer_bool_TCC4: OBLIGATION
	FORALL (l: [upto(dlimit) -> bool], d: device[maxrate, maxinfuse, maxtime]):
	    d > 0 AND l(d) IMPLIES d - 1 < d
	
	% The disjointness TCC (at line 442, column 4) in decl nil for
	% term generated from device_printer_bool
	%  COND d = 0 ->
	%        IF l(d) THEN concat(concat(" device(", real2str(d)), ")")
	%        ELSE ""
	%        ENDIF,
	%      d > 0 ->
	%        IF l(d)
	%          THEN concat(concat(concat(concat(" device(", real2str(d)),
	%                                    ")"),
	%                             device_printer_bool(l, d - 1)),
	%                      newline)
	%        ELSE device_printer_bool(l, d - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 442, column 4) in decl nil for
	% term generated from device_printer_bool
	%  COND d = 0 ->
	%        IF l(d) THEN concat(concat(" device(", real2str(d)), ")")
	%        ELSE ""
	%        ENDIF,
	%      d > 0 ->
	%        IF l(d)
	%          THEN concat(concat(concat(concat(" device(", real2str(d)),
	%                                    ")"),
	%                             device_printer_bool(l, d - 1)),
	%                      newline)
	%        ELSE device_printer_bool(l, d - 1)
	%        ENDIF
	% ENDCOND
	% Subtype TCC generated (at line 453, column 109) for  n - 1
	% expected type  node[maxrate, maxinfuse, maxtime]
	  % proved
	devs_printer_type_TCC1: OBLIGATION
	FORALL (l: [upto(nlimit) -> device_type[maxrate, maxinfuse, maxtime]],
	          n: node[maxrate, maxinfuse, maxtime]):
	    n > 0 AND l(n) /= no_device IMPLIES n - 1 >= 0 AND n - 1 <= nlimit
	
	% Termination TCC generated (at line 453, column 88) for
	% devs_printer_type(l, n - 1)
	  % proved
	devs_printer_type_TCC2: OBLIGATION
	FORALL (l: [upto(nlimit) -> device_type[maxrate, maxinfuse, maxtime]],
	          n: node[maxrate, maxinfuse, maxtime]):
	    n > 0 AND l(n) /= no_device IMPLIES n - 1 < n
	
	% The subtype TCC (at line 451, column 20) in decl nil for
	% term generated from devs_printer_type  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 451, column 69) in decl nil for
	% term generated from devs_printer_type  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 453, column 20) in decl nil for
	% term generated from devs_printer_type  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 453, column 69) in decl nil for
	% term generated from devs_printer_type  n
	% expected type  upto(nlimit)
	% The disjointness TCC (at line 450, column 4) in decl nil for
	% term generated from devs_printer_type
	%  COND n = 0 ->
	%        IF l(n) /= no_device
	%          THEN concat(concat(concat(concat("< device(", real2str(n)),
	%                                    "): "),
	%                             device_type2string(l(n))),
	%                      ">")
	%        ELSE " "
	%        ENDIF,
	%      n > 0 ->
	%        IF l(n) /= no_device
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat
	%                                      ("< device(", real2str(n)),
	%                                      "): "),
	%                                     device_type2string(l(n))),
	%                                    ">"),
	%                             space),
	%                      devs_printer_type(l, n - 1))
	%        ELSE devs_printer_type(l, n - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 450, column 4) in decl nil for
	% term generated from devs_printer_type
	%  COND n = 0 ->
	%        IF l(n) /= no_device
	%          THEN concat(concat(concat(concat("< device(", real2str(n)),
	%                                    "): "),
	%                             device_type2string(l(n))),
	%                      ">")
	%        ELSE " "
	%        ENDIF,
	%      n > 0 ->
	%        IF l(n) /= no_device
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat
	%                                      ("< device(", real2str(n)),
	%                                      "): "),
	%                                     device_type2string(l(n))),
	%                                    ">"),
	%                             space),
	%                      devs_printer_type(l, n - 1))
	%        ELSE devs_printer_type(l, n - 1)
	%        ENDIF
	% ENDCOND
	% Subtype TCC generated (at line 460, column 20) for  p
	% expected type  upto(plimit)
	  % proved
	patient_printer_bool_TCC1: OBLIGATION
	FORALL (p: patient[maxrate, maxinfuse, maxtime]): p = 0 IMPLIES p <= plimit
	
	% The subtype TCC (at line 451, column 20) in decl nil for
	 % term generated from devs_printer_type  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC1
	% The subtype TCC (at line 451, column 69) in decl nil for
	 % term generated from devs_printer_type  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC1
	% The subtype TCC (at line 453, column 20) in decl nil for
	 % term generated from devs_printer_type  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC2
	% The subtype TCC (at line 453, column 69) in decl nil for
	 % term generated from devs_printer_type  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC2
	% The disjointness TCC (at line 450, column 4) in decl nil for
	 % term generated from devs_printer_type
	    %  COND n = 0 ->
	    %        IF l(n) /= no_device
	    %          THEN concat(concat(concat(concat("< device(", real2str(n)),
	    %                                    "): "),
	    %                             device_type2string(l(n))),
	    %                      ">")
	    %        ELSE " "
	    %        ENDIF,
	    %      n > 0 ->
	    %        IF l(n) /= no_device
	    %          THEN concat(concat(concat(concat
	    %                                    (concat
	    %                                     (concat
	    %                                      ("< device(", real2str(n)),
	    %                                      "): "),
	    %                                     device_type2string(l(n))),
	    %                                    ">"),
	    %                             space),
	    %                      devs_printer_type(l, n - 1))
	    %        ELSE devs_printer_type(l, n - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 450, column 4) in decl nil for
	 % term generated from devs_printer_type
	    %  COND n = 0 ->
	    %        IF l(n) /= no_device
	    %          THEN concat(concat(concat(concat("< device(", real2str(n)),
	    %                                    "): "),
	    %                             device_type2string(l(n))),
	    %                      ">")
	    %        ELSE " "
	    %        ENDIF,
	    %      n > 0 ->
	    %        IF l(n) /= no_device
	    %          THEN concat(concat(concat(concat
	    %                                    (concat
	    %                                     (concat
	    %                                      ("< device(", real2str(n)),
	    %                                      "): "),
	    %                                     device_type2string(l(n))),
	    %                                    ">"),
	    %                             space),
	    %                      devs_printer_type(l, n - 1))
	    %        ELSE devs_printer_type(l, n - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	
	% Subtype TCC generated (at line 461, column 20) for  p
	% expected type  upto(plimit)
	  % proved
	patient_printer_bool_TCC2: OBLIGATION
	FORALL (p: patient[maxrate, maxinfuse, maxtime]): p > 0 IMPLIES p <= plimit
	
	% Subtype TCC generated (at line 461, column 83) for  p - 1
	% expected type  patient[maxrate, maxinfuse, maxtime]
	  % proved
	patient_printer_bool_TCC3: OBLIGATION
	FORALL (l: [upto(plimit) -> bool], p: patient[maxrate, maxinfuse, maxtime]):
	    p > 0 AND l(p) IMPLIES p - 1 >= 0 AND p - 1 <= nlimit
	
	% Termination TCC generated (at line 461, column 59) for
	% patient_printer_bool(l, p - 1)
	  % proved
	patient_printer_bool_TCC4: OBLIGATION
	FORALL (l: [upto(plimit) -> bool], p: patient[maxrate, maxinfuse, maxtime]):
	    p > 0 AND l(p) IMPLIES p - 1 < p
	
	% The disjointness TCC (at line 459, column 4) in decl nil for
	% term generated from patient_printer_bool
	%  COND p = 0 ->
	%        IF l(p) THEN concat(concat("patient(", real2str(p)), ")")
	%        ELSE " "
	%        ENDIF,
	%      p > 0 ->
	%        IF l(p)
	%          THEN concat(concat(concat(concat("patient(", real2str(p)),
	%                                    ")"),
	%                             space),
	%                      patient_printer_bool(l, p - 1))
	%        ELSE patient_printer_bool(l, p - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 459, column 4) in decl nil for
	% term generated from patient_printer_bool
	%  COND p = 0 ->
	%        IF l(p) THEN concat(concat("patient(", real2str(p)), ")")
	%        ELSE " "
	%        ENDIF,
	%      p > 0 ->
	%        IF l(p)
	%          THEN concat(concat(concat(concat("patient(", real2str(p)),
	%                                    ")"),
	%                             space),
	%                      patient_printer_bool(l, p - 1))
	%        ELSE patient_printer_bool(l, p - 1)
	%        ENDIF
	% ENDCOND
	% Subtype TCC generated (at line 469, column 22) for  n2
	% expected type  upto(nlimit)
	  % proved
	connected_printer_bool_TCC1: OBLIGATION
	FORALL (n1, n2: node[maxrate, maxinfuse, maxtime]):
	    n1 = 0 IMPLIES n2 <= nlimit
	
	% Subtype TCC generated (at line 471, column 22) for  n2
	% expected type  upto(nlimit)
	  % proved
	connected_printer_bool_TCC2: OBLIGATION
	FORALL (n1, n2: node[maxrate, maxinfuse, maxtime]):
	    n1 > 0 IMPLIES n2 <= nlimit
	
	% Subtype TCC generated (at line 473, column 44) for  n1 - 1
	% expected type  node[maxrate, maxinfuse, maxtime]
	  % proved
	connected_printer_bool_TCC3: OBLIGATION
	FORALL (l: [upto(nlimit), upto(nlimit) -> bool],
	          n1, n2: node[maxrate, maxinfuse, maxtime]):
	    n1 > 0 AND l(n1, n2) IMPLIES n1 - 1 >= 0 AND n1 - 1 <= nlimit
	
	% Termination TCC generated (at line 473, column 18) for
	% connected_printer_bool(l, n1 - 1, n2)
	  % proved
	connected_printer_bool_TCC4: OBLIGATION
	FORALL (l: [upto(nlimit), upto(nlimit) -> bool],
	          n1, n2: node[maxrate, maxinfuse, maxtime]):
	    n1 > 0 AND l(n1, n2) IMPLIES n1 - 1 < n1
	
	% The subtype TCC (at line 469, column 18) in decl nil for
	% term generated from connected_printer_bool  n1
	% expected type  upto(nlimit)
	% The subtype TCC (at line 471, column 18) in decl nil for
	% term generated from connected_printer_bool  n1
	% expected type  upto(nlimit)
	% The disjointness TCC (at line 468, column 0) in decl nil for
	% term generated from connected_printer_bool
	%  COND n1 = 0 ->
	%        IF l(n1, n2)
	%          THEN concat(concat(concat(concat
	%                                    (" nodes linked <", real2str(n1)),
	%                                    ","),
	%                             real2str(n2)),
	%                      ">")
	%        ELSE ""
	%        ENDIF,
	%      n1 > 0 ->
	%        IF l(n1, n2)
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (" nodes linked <",
	%                                      real2str(n1)),
	%                                     ","),
	%                                    real2str(n2)),
	%                             ">"),
	%                      connected_printer_bool(l, n1 - 1, n2))
	%        ELSE connected_printer_bool(l, n1 - 1, n2)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 468, column 0) in decl nil for
	% term generated from connected_printer_bool
	%  COND n1 = 0 ->
	%        IF l(n1, n2)
	%          THEN concat(concat(concat(concat
	%                                    (" nodes linked <", real2str(n1)),
	%                                    ","),
	%                             real2str(n2)),
	%                      ">")
	%        ELSE ""
	%        ENDIF,
	%      n1 > 0 ->
	%        IF l(n1, n2)
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (" nodes linked <",
	%                                      real2str(n1)),
	%                                     ","),
	%                                    real2str(n2)),
	%                             ">"),
	%                      connected_printer_bool(l, n1 - 1, n2))
	%        ELSE connected_printer_bool(l, n1 - 1, n2)
	%        ENDIF
	% ENDCOND
	% Subtype TCC generated (at line 483, column 38) for  n2 - 1
	% expected type  node[maxrate, maxinfuse, maxtime]
	  % proved
	nodes_link_printer_TCC1: OBLIGATION
	FORALL (n2: node[maxrate, maxinfuse, maxtime]):
	    n2 > 0 IMPLIES n2 - 1 >= 0 AND n2 - 1 <= nlimit
	
	% The subtype TCC (at line 469, column 18) in decl nil for
	 % term generated from connected_printer_bool  n1
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC1
	% The subtype TCC (at line 471, column 18) in decl nil for
	 % term generated from connected_printer_bool  n1
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC2
	% The disjointness TCC (at line 468, column 0) in decl nil for
	 % term generated from connected_printer_bool
	    %  COND n1 = 0 ->
	    %        IF l(n1, n2)
	    %          THEN concat(concat(concat(concat
	    %                                    (" nodes linked <", real2str(n1)),
	    %                                    ","),
	    %                             real2str(n2)),
	    %                      ">")
	    %        ELSE ""
	    %        ENDIF,
	    %      n1 > 0 ->
	    %        IF l(n1, n2)
	    %          THEN concat(concat(concat(concat
	    %                                    (concat
	    %                                     (" nodes linked <",
	    %                                      real2str(n1)),
	    %                                     ","),
	    %                                    real2str(n2)),
	    %                             ">"),
	    %                      connected_printer_bool(l, n1 - 1, n2))
	    %        ELSE connected_printer_bool(l, n1 - 1, n2)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 468, column 0) in decl nil for
	 % term generated from connected_printer_bool
	    %  COND n1 = 0 ->
	    %        IF l(n1, n2)
	    %          THEN concat(concat(concat(concat
	    %                                    (" nodes linked <", real2str(n1)),
	    %                                    ","),
	    %                             real2str(n2)),
	    %                      ">")
	    %        ELSE ""
	    %        ENDIF,
	    %      n1 > 0 ->
	    %        IF l(n1, n2)
	    %          THEN concat(concat(concat(concat
	    %                                    (concat
	    %                                     (" nodes linked <",
	    %                                      real2str(n1)),
	    %                                     ","),
	    %                                    real2str(n2)),
	    %                             ">"),
	    %                      connected_printer_bool(l, n1 - 1, n2))
	    %        ELSE connected_printer_bool(l, n1 - 1, n2)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	
	% Termination TCC generated (at line 483, column 12) for
	% nodes_link_printer(l, n1, n2 - 1)
	  % proved
	nodes_link_printer_TCC2: OBLIGATION
	FORALL (n2: node[maxrate, maxinfuse, maxtime]): n2 > 0 IMPLIES n2 - 1 < n2
	
	% The disjointness TCC (at line 480, column 0) in decl nil for
	% term generated from nodes_link_printer
	%  COND n2 = 0 -> connected_printer_bool(l, n1, n2),
	%      n2 > 0 ->
	%        concat(connected_printer_bool(l, n1, n2),
	%               nodes_link_printer(l, n1, n2 - 1))
	% ENDCOND
	% The coverage TCC (at line 480, column 0) in decl nil for
	% term generated from nodes_link_printer
	%  COND n2 = 0 -> connected_printer_bool(l, n1, n2),
	%      n2 > 0 ->
	%        concat(connected_printer_bool(l, n1, n2),
	%               nodes_link_printer(l, n1, n2 - 1))
	% ENDCOND
	% Subtype TCC generated (at line 488, column 25) for  c
	% expected type  [[upto(nlimit), upto(nlimit)] -> bool]
	  % proved
	connected2string_TCC1: OBLIGATION
	FORALL (x: nat): x <= nlimit IFF x <= nlimit
	
	% Subtype TCC generated (at line 488, column 28) for  nlimit
	% expected type  node[maxrate, maxinfuse, maxtime]
	  % proved
	connected2string_TCC2: OBLIGATION
	nlimit <= nlimit
	
	% The subtype TCC (at line 488, column 36) in decl nil for
	% term generated from connected2string  nlimit
	% expected type  node[maxrate, maxinfuse, maxtime]
	% The subtype TCC (at line 493, column 20) in decl nil for
	% term generated from node_to_integer_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 493, column 60) in decl nil for
	% term generated from node_to_integer_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 495, column 20) in decl nil for
	% term generated from node_to_integer_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 496, column 46) in decl nil for
	% term generated from node_to_integer_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 496, column 86) in decl nil for
	% term generated from node_to_integer_printer  n - 1
	% expected type  node[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 496, column 59) in decl nil for
	% term generated from node_to_integer_printer
	%  node_to_integer_printer(l, n - 1, nv)
	% The disjointness TCC (at line 492, column 4) in decl nil for
	% term generated from node_to_integer_printer
	%  COND n = 0 ->
	%        IF l(n) /= nv
	%          THEN concat(concat(concat("node(", real2str(n)), ") := "),
	%                      real2str(l(n)))
	%        ELSE ""
	%        ENDIF,
	%      n > 0 ->
	%        IF l(n) /= nv
	%          THEN concat(concat(concat(concat
	%                                    (concat("node(", real2str(n)),
	%                                     ") := "),
	%                                    real2str(l(n))),
	%                             space),
	%                      node_to_integer_printer(l, n - 1, nv))
	%        ELSE node_to_integer_printer(l, n - 1, nv)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 492, column 4) in decl nil for
	% term generated from node_to_integer_printer
	%  COND n = 0 ->
	%        IF l(n) /= nv
	%          THEN concat(concat(concat("node(", real2str(n)), ") := "),
	%                      real2str(l(n)))
	%        ELSE ""
	%        ENDIF,
	%      n > 0 ->
	%        IF l(n) /= nv
	%          THEN concat(concat(concat(concat
	%                                    (concat("node(", real2str(n)),
	%                                     ") := "),
	%                                    real2str(l(n))),
	%                             space),
	%                      node_to_integer_printer(l, n - 1, nv))
	%        ELSE node_to_integer_printer(l, n - 1, nv)
	%        ENDIF
	% ENDCOND
	% The subtype TCC (at line 514, column 20) in decl nil for
	% term generated from node_to_pd_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 514, column 69) in decl nil for
	% term generated from node_to_pd_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 516, column 20) in decl nil for
	% term generated from node_to_pd_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 517, column 46) in decl nil for
	% term generated from node_to_pd_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 518, column 42) in decl nil for
	% term generated from node_to_pd_printer  n - 1
	% expected type  node[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 518, column 20) in decl nil for
	% term generated from node_to_pd_printer
	%  node_to_pd_printer(l, n - 1)
	% The disjointness TCC (at line 513, column 4) in decl nil for
	% term generated from node_to_pd_printer
	%  COND n = 0 ->
	%        IF l(n)`pat /= p_null
	%          THEN concat(concat(concat(concat("<node(", real2str(n)),
	%                                    "), ("),
	%                             patient_to_device2string(l(n))),
	%                      ")>")
	%        ELSE ""
	%        ENDIF,
	%      n > 0 ->
	%        IF l(n)`pat /= p_null
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat("<node(", real2str(n)),
	%                                      "), ("),
	%                                     patient_to_device2string(l(n))),
	%                                    ")>"),
	%                             space),
	%                      node_to_pd_printer(l, n - 1))
	%        ELSE node_to_pd_printer(l, n - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 513, column 4) in decl nil for
	% term generated from node_to_pd_printer
	%  COND n = 0 ->
	%        IF l(n)`pat /= p_null
	%          THEN concat(concat(concat(concat("<node(", real2str(n)),
	%                                    "), ("),
	%                             patient_to_device2string(l(n))),
	%                      ")>")
	%        ELSE ""
	%        ENDIF,
	%      n > 0 ->
	%        IF l(n)`pat /= p_null
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat("<node(", real2str(n)),
	%                                      "), ("),
	%                                     patient_to_device2string(l(n))),
	%                                    ")>"),
	%                             space),
	%                      node_to_pd_printer(l, n - 1))
	%        ELSE node_to_pd_printer(l, n - 1)
	%        ENDIF
	% ENDCOND
	% The subtype TCC (at line 525, column 20) in decl nil for
	% term generated from node_to_patient_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 525, column 68) in decl nil for
	% term generated from node_to_patient_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 527, column 20) in decl nil for
	% term generated from node_to_patient_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 528, column 53) in decl nil for
	% term generated from node_to_patient_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 528, column 100) in decl nil for
	% term generated from node_to_patient_printer  n - 1
	% expected type  node[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 528, column 73) in decl nil for
	% term generated from node_to_patient_printer
	%  node_to_patient_printer(l, n - 1, pv)
	% The disjointness TCC (at line 524, column 4) in decl nil for
	% term generated from node_to_patient_printer
	%  COND n = 0 ->
	%        IF l(n) /= pv
	%          THEN concat(concat(concat(concat("< node(", real2str(n)),
	%                                    "), patient("),
	%                             real2str(l(n))),
	%                      ")>")
	%        ELSE ""
	%        ENDIF,
	%      n > 0 ->
	%        IF l(n) /= pv
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat("<node(", real2str(n)),
	%                                      "), patient("),
	%                                     real2str(l(n))),
	%                                    ")>"),
	%                             space),
	%                      node_to_patient_printer(l, n - 1, pv))
	%        ELSE node_to_patient_printer(l, n - 1, pv)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 524, column 4) in decl nil for
	% term generated from node_to_patient_printer
	%  COND n = 0 ->
	%        IF l(n) /= pv
	%          THEN concat(concat(concat(concat("< node(", real2str(n)),
	%                                    "), patient("),
	%                             real2str(l(n))),
	%                      ")>")
	%        ELSE ""
	%        ENDIF,
	%      n > 0 ->
	%        IF l(n) /= pv
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat("<node(", real2str(n)),
	%                                      "), patient("),
	%                                     real2str(l(n))),
	%                                    ")>"),
	%                             space),
	%                      node_to_patient_printer(l, n - 1, pv))
	%        ELSE node_to_patient_printer(l, n - 1, pv)
	%        ENDIF
	% ENDCOND
	% Subtype TCC generated (at line 535, column 20) for  i
	% expected type  upto(mindex)
	  % proved
	act_buff_printer_TCC1: OBLIGATION
	FORALL (i: index[maxrate, maxinfuse, maxtime]): i = 0 IMPLIES i <= mindex
	
	% The subtype TCC (at line 488, column 36) in decl nil for
	 % term generated from connected2string  nlimit
	    % expected type  node[maxrate, maxinfuse, maxtime]
	  % is subsumed by connected2string_TCC2
	% The subtype TCC (at line 493, column 20) in decl nil for
	 % term generated from node_to_integer_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC1
	% The subtype TCC (at line 493, column 60) in decl nil for
	 % term generated from node_to_integer_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC1
	% The subtype TCC (at line 495, column 20) in decl nil for
	 % term generated from node_to_integer_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC2
	% The subtype TCC (at line 496, column 46) in decl nil for
	 % term generated from node_to_integer_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC2
	% The subtype TCC (at line 496, column 86) in decl nil for
	 % term generated from node_to_integer_printer  n - 1
	    % expected type  node[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 496, column 59) in decl nil for
	 % term generated from node_to_integer_printer
	    %  node_to_integer_printer(l, n - 1, nv)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 492, column 4) in decl nil for
	 % term generated from node_to_integer_printer
	    %  COND n = 0 ->
	    %        IF l(n) /= nv
	    %          THEN concat(concat(concat("node(", real2str(n)), ") := "),
	    %                      real2str(l(n)))
	    %        ELSE ""
	    %        ENDIF,
	    %      n > 0 ->
	    %        IF l(n) /= nv
	    %          THEN concat(concat(concat(concat
	    %                                    (concat("node(", real2str(n)),
	    %                                     ") := "),
	    %                                    real2str(l(n))),
	    %                             space),
	    %                      node_to_integer_printer(l, n - 1, nv))
	    %        ELSE node_to_integer_printer(l, n - 1, nv)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 492, column 4) in decl nil for
	 % term generated from node_to_integer_printer
	    %  COND n = 0 ->
	    %        IF l(n) /= nv
	    %          THEN concat(concat(concat("node(", real2str(n)), ") := "),
	    %                      real2str(l(n)))
	    %        ELSE ""
	    %        ENDIF,
	    %      n > 0 ->
	    %        IF l(n) /= nv
	    %          THEN concat(concat(concat(concat
	    %                                    (concat("node(", real2str(n)),
	    %                                     ") := "),
	    %                                    real2str(l(n))),
	    %                             space),
	    %                      node_to_integer_printer(l, n - 1, nv))
	    %        ELSE node_to_integer_printer(l, n - 1, nv)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	% The subtype TCC (at line 514, column 20) in decl nil for
	 % term generated from node_to_pd_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC1
	% The subtype TCC (at line 514, column 69) in decl nil for
	 % term generated from node_to_pd_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC1
	% The subtype TCC (at line 516, column 20) in decl nil for
	 % term generated from node_to_pd_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC2
	% The subtype TCC (at line 517, column 46) in decl nil for
	 % term generated from node_to_pd_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC2
	% The subtype TCC (at line 518, column 42) in decl nil for
	 % term generated from node_to_pd_printer  n - 1
	    % expected type  node[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 518, column 20) in decl nil for
	 % term generated from node_to_pd_printer
	    %  node_to_pd_printer(l, n - 1)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 513, column 4) in decl nil for
	 % term generated from node_to_pd_printer
	    %  COND n = 0 ->
	    %        IF l(n)`pat /= p_null
	    %          THEN concat(concat(concat(concat("<node(", real2str(n)),
	    %                                    "), ("),
	    %                             patient_to_device2string(l(n))),
	    %                      ")>")
	    %        ELSE ""
	    %        ENDIF,
	    %      n > 0 ->
	    %        IF l(n)`pat /= p_null
	    %          THEN concat(concat(concat(concat
	    %                                    (concat
	    %                                     (concat("<node(", real2str(n)),
	    %                                      "), ("),
	    %                                     patient_to_device2string(l(n))),
	    %                                    ")>"),
	    %                             space),
	    %                      node_to_pd_printer(l, n - 1))
	    %        ELSE node_to_pd_printer(l, n - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 513, column 4) in decl nil for
	 % term generated from node_to_pd_printer
	    %  COND n = 0 ->
	    %        IF l(n)`pat /= p_null
	    %          THEN concat(concat(concat(concat("<node(", real2str(n)),
	    %                                    "), ("),
	    %                             patient_to_device2string(l(n))),
	    %                      ")>")
	    %        ELSE ""
	    %        ENDIF,
	    %      n > 0 ->
	    %        IF l(n)`pat /= p_null
	    %          THEN concat(concat(concat(concat
	    %                                    (concat
	    %                                     (concat("<node(", real2str(n)),
	    %                                      "), ("),
	    %                                     patient_to_device2string(l(n))),
	    %                                    ")>"),
	    %                             space),
	    %                      node_to_pd_printer(l, n - 1))
	    %        ELSE node_to_pd_printer(l, n - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	% The subtype TCC (at line 525, column 20) in decl nil for
	 % term generated from node_to_patient_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC1
	% The subtype TCC (at line 525, column 68) in decl nil for
	 % term generated from node_to_patient_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC1
	% The subtype TCC (at line 527, column 20) in decl nil for
	 % term generated from node_to_patient_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC2
	% The subtype TCC (at line 528, column 53) in decl nil for
	 % term generated from node_to_patient_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC2
	% The subtype TCC (at line 528, column 100) in decl nil for
	 % term generated from node_to_patient_printer  n - 1
	    % expected type  node[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 528, column 73) in decl nil for
	 % term generated from node_to_patient_printer
	    %  node_to_patient_printer(l, n - 1, pv)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 524, column 4) in decl nil for
	 % term generated from node_to_patient_printer
	    %  COND n = 0 ->
	    %        IF l(n) /= pv
	    %          THEN concat(concat(concat(concat("< node(", real2str(n)),
	    %                                    "), patient("),
	    %                             real2str(l(n))),
	    %                      ")>")
	    %        ELSE ""
	    %        ENDIF,
	    %      n > 0 ->
	    %        IF l(n) /= pv
	    %          THEN concat(concat(concat(concat
	    %                                    (concat
	    %                                     (concat("<node(", real2str(n)),
	    %                                      "), patient("),
	    %                                     real2str(l(n))),
	    %                                    ")>"),
	    %                             space),
	    %                      node_to_patient_printer(l, n - 1, pv))
	    %        ELSE node_to_patient_printer(l, n - 1, pv)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 524, column 4) in decl nil for
	 % term generated from node_to_patient_printer
	    %  COND n = 0 ->
	    %        IF l(n) /= pv
	    %          THEN concat(concat(concat(concat("< node(", real2str(n)),
	    %                                    "), patient("),
	    %                             real2str(l(n))),
	    %                      ")>")
	    %        ELSE ""
	    %        ENDIF,
	    %      n > 0 ->
	    %        IF l(n) /= pv
	    %          THEN concat(concat(concat(concat
	    %                                    (concat
	    %                                     (concat("<node(", real2str(n)),
	    %                                      "), patient("),
	    %                                     real2str(l(n))),
	    %                                    ")>"),
	    %                             space),
	    %                      node_to_patient_printer(l, n - 1, pv))
	    %        ELSE node_to_patient_printer(l, n - 1, pv)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	
	% Subtype TCC generated (at line 537, column 20) for  i
	% expected type  upto(mindex)
	  % proved
	act_buff_printer_TCC2: OBLIGATION
	FORALL (i: index[maxrate, maxinfuse, maxtime]): i > 0 IMPLIES i <= mindex
	
	% Subtype TCC generated (at line 538, column 80) for  i - 1
	% expected type  index[maxrate, maxinfuse, maxtime]
	  % proved
	act_buff_printer_TCC3: OBLIGATION
	FORALL (l: [upto(mindex) -> act_message_type[maxrate, maxinfuse, maxtime]],
	          i: index[maxrate, maxinfuse, maxtime]):
	    i > 0 AND l(i)`mhdr /= nomsg IMPLIES i - 1 >= 0 AND i - 1 <= mindex
	
	% Termination TCC generated (at line 538, column 60) for
	% act_buff_printer(l, i - 1)
	  % proved
	act_buff_printer_TCC4: OBLIGATION
	FORALL (l: [upto(mindex) -> act_message_type[maxrate, maxinfuse, maxtime]],
	          i: index[maxrate, maxinfuse, maxtime]):
	    i > 0 AND l(i)`mhdr /= nomsg IMPLIES i - 1 < i
	
	% Disjointness TCC generated (at line 534, column 4) for
	% COND i = 0 ->
	%        IF l(i)`mhdr /= nomsg
	%          THEN concat(concat(concat(concat("index(", real2str(i)),
	%                                    ") := "),
	%                             act_msg_type2string(l(i))),
	%                      newline)
	%        ELSE ""
	%        ENDIF,
	%      i > 0 ->
	%        IF l(i)`mhdr /= nomsg
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat("index(", real2str(i)),
	%                                      ") := "),
	%                                     act_msg_type2string(l(i))),
	%                                    space),
	%                             act_buff_printer(l, i - 1)),
	%                      newline)
	%        ELSE act_buff_printer(l, i - 1)
	%        ENDIF
	% ENDCOND
	  % proved
	act_buff_printer_TCC5: OBLIGATION
	FORALL (i: index[maxrate, maxinfuse, maxtime]): NOT (i = 0 AND i > 0)
	
	% Coverage TCC generated (at line 534, column 4) for
	% COND i = 0 ->
	%        IF l(i)`mhdr /= nomsg
	%          THEN concat(concat(concat(concat("index(", real2str(i)),
	%                                    ") := "),
	%                             act_msg_type2string(l(i))),
	%                      newline)
	%        ELSE ""
	%        ENDIF,
	%      i > 0 ->
	%        IF l(i)`mhdr /= nomsg
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat("index(", real2str(i)),
	%                                      ") := "),
	%                                     act_msg_type2string(l(i))),
	%                                    space),
	%                             act_buff_printer(l, i - 1)),
	%                      newline)
	%        ELSE act_buff_printer(l, i - 1)
	%        ENDIF
	% ENDCOND
	  % proved
	act_buff_printer_TCC6: OBLIGATION
	FORALL (i: index[maxrate, maxinfuse, maxtime]): i = 0 OR i > 0
	
	% The subtype TCC (at line 535, column 69) in decl nil for
	% term generated from act_buff_printer  i
	% expected type  upto(mindex)
	% The subtype TCC (at line 538, column 47) in decl nil for
	% term generated from act_buff_printer  i
	% expected type  upto(mindex)
	% Subtype TCC generated (at line 548, column 80) for  i - 1
	% expected type  index[maxrate, maxinfuse, maxtime]
	  % proved
	pan_buff_printer_TCC1: OBLIGATION
	FORALL (l: [upto(mindex) -> pan_message_type[maxrate, maxinfuse, maxtime]],
	          i: index[maxrate, maxinfuse, maxtime]):
	    i > 0 AND l(i)`mhdr /= nomsg IMPLIES i - 1 >= 0 AND i - 1 <= mindex
	
	% The subtype TCC (at line 535, column 69) in decl nil for
	 % term generated from act_buff_printer  i
	    % expected type  upto(mindex)
	  % is subsumed by act_buff_printer_TCC1
	% The subtype TCC (at line 538, column 47) in decl nil for
	 % term generated from act_buff_printer  i
	    % expected type  upto(mindex)
	  % is subsumed by act_buff_printer_TCC2
	
	% Termination TCC generated (at line 548, column 60) for
	% pan_buff_printer(l, i - 1)
	  % proved
	pan_buff_printer_TCC2: OBLIGATION
	FORALL (l: [upto(mindex) -> pan_message_type[maxrate, maxinfuse, maxtime]],
	          i: index[maxrate, maxinfuse, maxtime]):
	    i > 0 AND l(i)`mhdr /= nomsg IMPLIES i - 1 < i
	
	% The subtype TCC (at line 545, column 20) in decl nil for
	% term generated from pan_buff_printer  i
	% expected type  upto(mindex)
	% The subtype TCC (at line 545, column 69) in decl nil for
	% term generated from pan_buff_printer  i
	% expected type  upto(mindex)
	% The subtype TCC (at line 547, column 20) in decl nil for
	% term generated from pan_buff_printer  i
	% expected type  upto(mindex)
	% The subtype TCC (at line 548, column 47) in decl nil for
	% term generated from pan_buff_printer  i
	% expected type  upto(mindex)
	% The disjointness TCC (at line 544, column 4) in decl nil for
	% term generated from pan_buff_printer
	%  COND i = 0 ->
	%        IF l(i)`mhdr /= nomsg
	%          THEN concat(concat(concat(concat("index(", real2str(i)),
	%                                    ") := "),
	%                             pan_message_type2string(l(i))),
	%                      newline)
	%        ELSE ""
	%        ENDIF,
	%      i > 0 ->
	%        IF l(i)`mhdr /= nomsg
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat("index(", real2str(i)),
	%                                      ") := "),
	%                                     pan_message_type2string(l(i))),
	%                                    space),
	%                             pan_buff_printer(l, i - 1)),
	%                      newline)
	%        ELSE pan_buff_printer(l, i - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 544, column 4) in decl nil for
	% term generated from pan_buff_printer
	%  COND i = 0 ->
	%        IF l(i)`mhdr /= nomsg
	%          THEN concat(concat(concat(concat("index(", real2str(i)),
	%                                    ") := "),
	%                             pan_message_type2string(l(i))),
	%                      newline)
	%        ELSE ""
	%        ENDIF,
	%      i > 0 ->
	%        IF l(i)`mhdr /= nomsg
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat("index(", real2str(i)),
	%                                      ") := "),
	%                                     pan_message_type2string(l(i))),
	%                                    space),
	%                             pan_buff_printer(l, i - 1)),
	%                      newline)
	%        ELSE pan_buff_printer(l, i - 1)
	%        ENDIF
	% ENDCOND
	% Subtype TCC generated (at line 555, column 20) for  p
	% expected type  upto(mindex)
	  % proved
	patient_pan_printer_TCC1: OBLIGATION
	FORALL (p: patient[maxrate, maxinfuse, maxtime]): p = 0 IMPLIES p <= mindex
	
	% The subtype TCC (at line 545, column 20) in decl nil for
	 % term generated from pan_buff_printer  i
	    % expected type  upto(mindex)
	  % is subsumed by act_buff_printer_TCC1
	% The subtype TCC (at line 545, column 69) in decl nil for
	 % term generated from pan_buff_printer  i
	    % expected type  upto(mindex)
	  % is subsumed by act_buff_printer_TCC1
	% The subtype TCC (at line 547, column 20) in decl nil for
	 % term generated from pan_buff_printer  i
	    % expected type  upto(mindex)
	  % is subsumed by act_buff_printer_TCC2
	% The subtype TCC (at line 548, column 47) in decl nil for
	 % term generated from pan_buff_printer  i
	    % expected type  upto(mindex)
	  % is subsumed by act_buff_printer_TCC2
	% The disjointness TCC (at line 544, column 4) in decl nil for
	 % term generated from pan_buff_printer
	    %  COND i = 0 ->
	    %        IF l(i)`mhdr /= nomsg
	    %          THEN concat(concat(concat(concat("index(", real2str(i)),
	    %                                    ") := "),
	    %                             pan_message_type2string(l(i))),
	    %                      newline)
	    %        ELSE ""
	    %        ENDIF,
	    %      i > 0 ->
	    %        IF l(i)`mhdr /= nomsg
	    %          THEN concat(concat(concat(concat
	    %                                    (concat
	    %                                     (concat("index(", real2str(i)),
	    %                                      ") := "),
	    %                                     pan_message_type2string(l(i))),
	    %                                    space),
	    %                             pan_buff_printer(l, i - 1)),
	    %                      newline)
	    %        ELSE pan_buff_printer(l, i - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by act_buff_printer_TCC5
	% The coverage TCC (at line 544, column 4) in decl nil for
	 % term generated from pan_buff_printer
	    %  COND i = 0 ->
	    %        IF l(i)`mhdr /= nomsg
	    %          THEN concat(concat(concat(concat("index(", real2str(i)),
	    %                                    ") := "),
	    %                             pan_message_type2string(l(i))),
	    %                      newline)
	    %        ELSE ""
	    %        ENDIF,
	    %      i > 0 ->
	    %        IF l(i)`mhdr /= nomsg
	    %          THEN concat(concat(concat(concat
	    %                                    (concat
	    %                                     (concat("index(", real2str(i)),
	    %                                      ") := "),
	    %                                     pan_message_type2string(l(i))),
	    %                                    space),
	    %                             pan_buff_printer(l, i - 1)),
	    %                      newline)
	    %        ELSE pan_buff_printer(l, i - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by act_buff_printer_TCC6
	
	% Subtype TCC generated (at line 557, column 20) for  p
	% expected type  upto(mindex)
	  % proved
	patient_pan_printer_TCC2: OBLIGATION
	FORALL (p: patient[maxrate, maxinfuse, maxtime]): p > 0 IMPLIES p <= mindex
	
	% The subtype TCC (at line 555, column 74) in decl nil for
	% term generated from patient_pan_printer  p
	% expected type  upto(mindex)
	% The subtype TCC (at line 558, column 49) in decl nil for
	% term generated from patient_pan_printer  p
	% expected type  upto(mindex)
	% The subtype TCC (at line 558, column 85) in decl nil for
	% term generated from patient_pan_printer  p - 1
	% expected type  patient[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 558, column 62) in decl nil for
	% term generated from patient_pan_printer
	%  patient_pan_printer(l, p - 1)
	% The disjointness TCC (at line 554, column 0) in decl nil for
	% term generated from patient_pan_printer
	%  COND p = 0 ->
	%        IF l(p)`pars /= emptyset
	%          THEN concat(concat(concat("patient(", real2str(p)),
	%                             ") := "),
	%                      panel2string(l(p)))
	%        ELSE ""
	%        ENDIF,
	%      p > 0 ->
	%        IF l(p)`pars /= emptyset
	%          THEN concat(concat(concat(concat
	%                                    (concat("patient(", real2str(p)),
	%                                     ") := "),
	%                                    panel2string(l(p))),
	%                             space),
	%                      patient_pan_printer(l, p - 1))
	%        ELSE patient_pan_printer(l, p - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 554, column 0) in decl nil for
	% term generated from patient_pan_printer
	%  COND p = 0 ->
	%        IF l(p)`pars /= emptyset
	%          THEN concat(concat(concat("patient(", real2str(p)),
	%                             ") := "),
	%                      panel2string(l(p)))
	%        ELSE ""
	%        ENDIF,
	%      p > 0 ->
	%        IF l(p)`pars /= emptyset
	%          THEN concat(concat(concat(concat
	%                                    (concat("patient(", real2str(p)),
	%                                     ") := "),
	%                                    panel2string(l(p))),
	%                             space),
	%                      patient_pan_printer(l, p - 1))
	%        ELSE patient_pan_printer(l, p - 1)
	%        ENDIF
	% ENDCOND
	% Disjointness TCC generated (at line 564, column 3) for
	% COND m = error -> "error",
	%      m = top -> "top",
	%      m = p_mode -> "p_mode",
	%      m = d_mode -> "d_mode",
	%      m = dc_mode -> "dc_mode"
	% ENDCOND
	  % proved
	patient_mode_type2string_TCC1: OBLIGATION
	FORALL (m: patient_mode_type):
	         (NOT (m = error AND m = top)) AND (NOT (m = error AND m = p_mode))
	     AND (NOT (m = error AND m = d_mode)) AND (NOT (m = error AND m = dc_mode))
	     AND (NOT (m = top AND m = p_mode)) AND (NOT (m = top AND m = d_mode))
	     AND (NOT (m = top AND m = dc_mode)) AND (NOT (m = p_mode AND m = d_mode))
	     AND (NOT (m = p_mode AND m = dc_mode))
	     AND NOT (m = d_mode AND m = dc_mode)
	
	% The subtype TCC (at line 555, column 74) in decl nil for
	 % term generated from patient_pan_printer  p
	    % expected type  upto(mindex)
	  % is subsumed by patient_pan_printer_TCC1
	% The subtype TCC (at line 558, column 49) in decl nil for
	 % term generated from patient_pan_printer  p
	    % expected type  upto(mindex)
	  % is subsumed by patient_pan_printer_TCC2
	% The subtype TCC (at line 558, column 85) in decl nil for
	 % term generated from patient_pan_printer  p - 1
	    % expected type  patient[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 558, column 62) in decl nil for
	 % term generated from patient_pan_printer
	    %  patient_pan_printer(l, p - 1)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 554, column 0) in decl nil for
	 % term generated from patient_pan_printer
	    %  COND p = 0 ->
	    %        IF l(p)`pars /= emptyset
	    %          THEN concat(concat(concat("patient(", real2str(p)),
	    %                             ") := "),
	    %                      panel2string(l(p)))
	    %        ELSE ""
	    %        ENDIF,
	    %      p > 0 ->
	    %        IF l(p)`pars /= emptyset
	    %          THEN concat(concat(concat(concat
	    %                                    (concat("patient(", real2str(p)),
	    %                                     ") := "),
	    %                                    panel2string(l(p))),
	    %                             space),
	    %                      patient_pan_printer(l, p - 1))
	    %        ELSE patient_pan_printer(l, p - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 554, column 0) in decl nil for
	 % term generated from patient_pan_printer
	    %  COND p = 0 ->
	    %        IF l(p)`pars /= emptyset
	    %          THEN concat(concat(concat("patient(", real2str(p)),
	    %                             ") := "),
	    %                      panel2string(l(p)))
	    %        ELSE ""
	    %        ENDIF,
	    %      p > 0 ->
	    %        IF l(p)`pars /= emptyset
	    %          THEN concat(concat(concat(concat
	    %                                    (concat("patient(", real2str(p)),
	    %                                     ") := "),
	    %                                    panel2string(l(p))),
	    %                             space),
	    %                      patient_pan_printer(l, p - 1))
	    %        ELSE patient_pan_printer(l, p - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	
	% Coverage TCC generated (at line 564, column 3) for
	% COND m = error -> "error",
	%      m = top -> "top",
	%      m = p_mode -> "p_mode",
	%      m = d_mode -> "d_mode",
	%      m = dc_mode -> "dc_mode"
	% ENDCOND
	  % proved
	patient_mode_type2string_TCC2: OBLIGATION
	FORALL (m: patient_mode_type):
	         (m = error) OR (m = top) OR (m = p_mode) OR (m = d_mode)
	     OR (m = dc_mode)
	
	% Disjointness TCC generated (at line 574, column 3) for
	% COND m = edit_none -> "edit_none",
	%      m = edit_top -> "edit_top",
	%      m = edit_patient -> "edit_patient",
	%      m = edit_device -> "edit_device",
	%      m = edit_rule -> "edit_rule",
	%      m = edit_constraint -> "edit_constraint"
	% ENDCOND
	  % proved
	patient_edit_type2string_TCC1: OBLIGATION
	FORALL (m: patient_edit_type):
	         (NOT (m = edit_none AND m = edit_top))
	     AND (NOT (m = edit_none AND m = edit_patient))
	     AND (NOT (m = edit_none AND m = edit_device))
	     AND (NOT (m = edit_none AND m = edit_rule))
	     AND (NOT (m = edit_none AND m = edit_constraint))
	     AND (NOT (m = edit_top AND m = edit_patient))
	     AND (NOT (m = edit_top AND m = edit_device))
	     AND (NOT (m = edit_top AND m = edit_rule))
	     AND (NOT (m = edit_top AND m = edit_constraint))
	     AND (NOT (m = edit_patient AND m = edit_device))
	     AND (NOT (m = edit_patient AND m = edit_rule))
	     AND (NOT (m = edit_patient AND m = edit_constraint))
	     AND (NOT (m = edit_device AND m = edit_rule))
	     AND (NOT (m = edit_device AND m = edit_constraint))
	     AND NOT (m = edit_rule AND m = edit_constraint)
	
	% Coverage TCC generated (at line 574, column 3) for
	% COND m = edit_none -> "edit_none",
	%      m = edit_top -> "edit_top",
	%      m = edit_patient -> "edit_patient",
	%      m = edit_device -> "edit_device",
	%      m = edit_rule -> "edit_rule",
	%      m = edit_constraint -> "edit_constraint"
	% ENDCOND
	  % proved
	patient_edit_type2string_TCC2: OBLIGATION
	FORALL (m: patient_edit_type):
	         (m = edit_none) OR (m = edit_top) OR (m = edit_patient)
	     OR (m = edit_device) OR (m = edit_rule) OR (m = edit_constraint)
	
	% The subtype TCC (at line 585, column 26) in decl nil for
	% term generated from nodes2string  ns
	% expected type  [upto(nlimit) -> bool]
	% The subtype TCC (at line 585, column 30) in decl nil for
	% term generated from nodes2string  nlimit
	% expected type  node[maxrate, maxinfuse, maxtime]
	% Subtype TCC generated (at line 589, column 29) for  ds
	% expected type  [upto(dlimit) -> bool]
	  % proved
	devices2string_TCC1: OBLIGATION
	FORALL (ds: devices[maxrate, maxinfuse, maxtime]):
	    FORALL (x: nat): ds(x) IMPLIES (x <= nlimit IFF x <= dlimit)
	
	% The subtype TCC (at line 585, column 26) in decl nil for
	 % term generated from nodes2string  ns
	    % expected type  [upto(nlimit) -> bool]
	  % is subsumed by connected2string_TCC1
	% The subtype TCC (at line 585, column 30) in decl nil for
	 % term generated from nodes2string  nlimit
	    % expected type  node[maxrate, maxinfuse, maxtime]
	  % is subsumed by connected2string_TCC2
	
	% Subtype TCC generated (at line 589, column 33) for  dlimit
	% expected type  device[maxrate, maxinfuse, maxtime]
	  % proved
	devices2string_TCC2: OBLIGATION
	dlimit <= nlimit
	
	% Subtype TCC generated (at line 593, column 30) for  ps
	% expected type  [upto(plimit) -> bool]
	  % proved
	patients_type2string_TCC1: OBLIGATION
	FORALL (ps: patients_type[maxrate, maxinfuse, maxtime]):
	    FORALL (x: nat): ps(x) IMPLIES (x <= nlimit IFF x <= plimit)
	
	% Subtype TCC generated (at line 593, column 34) for  plimit
	% expected type  patient[maxrate, maxinfuse, maxtime]
	  % proved
	patients_type2string_TCC2: OBLIGATION
	plimit <= nlimit
	
	% The subtype TCC (at line 597, column 27) in decl nil for
	% term generated from devices_type2string  ds
	% expected type  [upto(nlimit) ->
	%    device_type[maxrate, maxinfuse, maxtime]]
	% The subtype TCC (at line 597, column 31) in decl nil for
	% term generated from devices_type2string  dlimit
	% expected type  node[maxrate, maxinfuse, maxtime]
	% Subtype TCC generated (at line 601, column 26) for  ab
	% expected type  [upto(mindex) ->
	%    act_message_type[maxrate, maxinfuse, maxtime]]
	  % proved
	act_buff_type2string_TCC1: OBLIGATION
	FORALL (x: nat): x <= mindex IFF x <= mindex
	
	% The subtype TCC (at line 597, column 27) in decl nil for
	 % term generated from devices_type2string  ds
	    % expected type  [upto(nlimit) ->
	                   %    device_type[maxrate, maxinfuse, maxtime]]
	  % is subsumed by connected2string_TCC1
	% The subtype TCC (at line 597, column 31) in decl nil for
	 % term generated from devices_type2string  dlimit
	    % expected type  node[maxrate, maxinfuse, maxtime]
	  % is subsumed by devices2string_TCC2
	
	% Subtype TCC generated (at line 601, column 30) for  mindex
	% expected type  index[maxrate, maxinfuse, maxtime]
	  % proved
	act_buff_type2string_TCC2: OBLIGATION
	mindex <= mindex
	
	% The subtype TCC (at line 605, column 26) in decl nil for
	% term generated from pan_buff_type2string  pb
	% expected type  [upto(mindex) ->
	%    pan_message_type[maxrate, maxinfuse, maxtime]]
	% The subtype TCC (at line 605, column 30) in decl nil for
	% term generated from pan_buff_type2string  mindex
	% expected type  index[maxrate, maxinfuse, maxtime]
	% The subtype TCC (at line 647, column 20) in decl nil for
	% term generated from pan_msg_waiting_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 647, column 74) in decl nil for
	% term generated from pan_msg_waiting_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 649, column 20) in decl nil for
	% term generated from pan_msg_waiting_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 650, column 46) in decl nil for
	% term generated from pan_msg_waiting_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 650, column 86) in decl nil for
	% term generated from pan_msg_waiting_printer  n - 1
	% expected type  node[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 650, column 59) in decl nil for
	% term generated from pan_msg_waiting_printer
	%  pan_msg_waiting_printer(l, n - 1)
	% The disjointness TCC (at line 646, column 1) in decl nil for
	% term generated from pan_msg_waiting_printer
	%  COND n = 0 ->
	%        IF l(n)`buf_status /= empty
	%          THEN concat(concat(concat(concat("node(", real2str(n)),
	%                                    ") := "),
	%                             pan_q_type2string(l(n))),
	%                      newline)
	%        ELSE ""
	%        ENDIF,
	%      n > 0 ->
	%        IF l(n)`buf_status /= empty
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat("node(", real2str(n)),
	%                                      ") := "),
	%                                     pan_q_type2string(l(n))),
	%                                    space),
	%                             pan_msg_waiting_printer(l, n - 1)),
	%                      newline)
	%        ELSE pan_msg_waiting_printer(l, n - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 646, column 1) in decl nil for
	% term generated from pan_msg_waiting_printer
	%  COND n = 0 ->
	%        IF l(n)`buf_status /= empty
	%          THEN concat(concat(concat(concat("node(", real2str(n)),
	%                                    ") := "),
	%                             pan_q_type2string(l(n))),
	%                      newline)
	%        ELSE ""
	%        ENDIF,
	%      n > 0 ->
	%        IF l(n)`buf_status /= empty
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat("node(", real2str(n)),
	%                                      ") := "),
	%                                     pan_q_type2string(l(n))),
	%                                    space),
	%                             pan_msg_waiting_printer(l, n - 1)),
	%                      newline)
	%        ELSE pan_msg_waiting_printer(l, n - 1)
	%        ENDIF
	% ENDCOND
	% The subtype TCC (at line 657, column 20) in decl nil for
	% term generated from act_msg_waiting_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 657, column 74) in decl nil for
	% term generated from act_msg_waiting_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 659, column 20) in decl nil for
	% term generated from act_msg_waiting_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 660, column 46) in decl nil for
	% term generated from act_msg_waiting_printer  n
	% expected type  upto(nlimit)
	% The subtype TCC (at line 660, column 86) in decl nil for
	% term generated from act_msg_waiting_printer  n - 1
	% expected type  node[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 660, column 59) in decl nil for
	% term generated from act_msg_waiting_printer
	%  act_msg_waiting_printer(l, n - 1)
	% The disjointness TCC (at line 656, column 1) in decl nil for
	% term generated from act_msg_waiting_printer
	%  COND n = 0 ->
	%        IF l(n)`buf_status /= empty
	%          THEN concat(concat(concat(concat("node(", real2str(n)),
	%                                    ") := "),
	%                             act_q_type2string(l(n))),
	%                      newline)
	%        ELSE ""
	%        ENDIF,
	%      n > 0 ->
	%        IF l(n)`buf_status /= empty
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat("node(", real2str(n)),
	%                                      ") := "),
	%                                     act_q_type2string(l(n))),
	%                                    space),
	%                             act_msg_waiting_printer(l, n - 1)),
	%                      newline)
	%        ELSE act_msg_waiting_printer(l, n - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 656, column 1) in decl nil for
	% term generated from act_msg_waiting_printer
	%  COND n = 0 ->
	%        IF l(n)`buf_status /= empty
	%          THEN concat(concat(concat(concat("node(", real2str(n)),
	%                                    ") := "),
	%                             act_q_type2string(l(n))),
	%                      newline)
	%        ELSE ""
	%        ENDIF,
	%      n > 0 ->
	%        IF l(n)`buf_status /= empty
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat("node(", real2str(n)),
	%                                      ") := "),
	%                                     act_q_type2string(l(n))),
	%                                    space),
	%                             act_msg_waiting_printer(l, n - 1)),
	%                      newline)
	%        ELSE act_msg_waiting_printer(l, n - 1)
	%        ENDIF
	% ENDCOND
	% The subtype TCC (at line 668, column 13) in decl nil for
	% term generated from d_panel_type_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 668, column 67) in decl nil for
	% term generated from d_panel_type_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 670, column 13) in decl nil for
	% term generated from d_panel_type_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 671, column 42) in decl nil for
	% term generated from d_panel_type_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 671, column 71) in decl nil for
	% term generated from d_panel_type_printer  d - 1
	% expected type  device[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 671, column 47) in decl nil for
	% term generated from d_panel_type_printer
	%  d_panel_type_printer(l, d - 1)
	% The disjointness TCC (at line 666, column 1) in decl nil for
	% term generated from d_panel_type_printer
	%  COND d = 0 ->
	%        IF l(d)`pars /= emptyset
	%          THEN concat(concat(concat(" device(", real2str(d)),
	%                             ") := "),
	%                      panel2string(l(d)))
	%        ELSE ""
	%        ENDIF,
	%      d > 0 ->
	%        IF l(d)`pars /= emptyset
	%          THEN concat(concat(concat(concat(" device(", real2str(d)),
	%                                    ") := "),
	%                             panel2string(l(d))),
	%                      d_panel_type_printer(l, d - 1))
	%        ELSE d_panel_type_printer(l, d - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 666, column 1) in decl nil for
	% term generated from d_panel_type_printer
	%  COND d = 0 ->
	%        IF l(d)`pars /= emptyset
	%          THEN concat(concat(concat(" device(", real2str(d)),
	%                             ") := "),
	%                      panel2string(l(d)))
	%        ELSE ""
	%        ENDIF,
	%      d > 0 ->
	%        IF l(d)`pars /= emptyset
	%          THEN concat(concat(concat(concat(" device(", real2str(d)),
	%                                    ") := "),
	%                             panel2string(l(d))),
	%                      d_panel_type_printer(l, d - 1))
	%        ELSE d_panel_type_printer(l, d - 1)
	%        ENDIF
	% ENDCOND
	% The subtype TCC (at line 678, column 20) in decl nil for
	% term generated from p_dstates_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 678, column 71) in decl nil for
	% term generated from p_dstates_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 680, column 20) in decl nil for
	% term generated from p_dstates_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 681, column 48) in decl nil for
	% term generated from p_dstates_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 681, column 82) in decl nil for
	% term generated from p_dstates_printer  d - 1
	% expected type  device[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 681, column 61) in decl nil for
	% term generated from p_dstates_printer
	%  p_dstates_printer(l, d - 1)
	% The disjointness TCC (at line 677, column 3) in decl nil for
	% term generated from p_dstates_printer
	%  COND d = 0 ->
	%        IF l(d)`nde /= no_node
	%          THEN concat(concat(concat("device(", real2str(d)), ") := "),
	%                      d_state2string(l(d)))
	%        ELSE ""
	%        ENDIF,
	%      d > 0 ->
	%        IF l(d)`nde /= no_node
	%          THEN concat(concat(concat(concat
	%                                    (concat("device(", real2str(d)),
	%                                     ") := "),
	%                                    d_state2string(l(d))),
	%                             space),
	%                      p_dstates_printer(l, d - 1))
	%        ELSE p_dstates_printer(l, d - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 677, column 3) in decl nil for
	% term generated from p_dstates_printer
	%  COND d = 0 ->
	%        IF l(d)`nde /= no_node
	%          THEN concat(concat(concat("device(", real2str(d)), ") := "),
	%                      d_state2string(l(d)))
	%        ELSE ""
	%        ENDIF,
	%      d > 0 ->
	%        IF l(d)`nde /= no_node
	%          THEN concat(concat(concat(concat
	%                                    (concat("device(", real2str(d)),
	%                                     ") := "),
	%                                    d_state2string(l(d))),
	%                             space),
	%                      p_dstates_printer(l, d - 1))
	%        ELSE p_dstates_printer(l, d - 1)
	%        ENDIF
	% ENDCOND
	% The subtype TCC (at line 688, column 20) in decl nil for
	% term generated from main_act_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 688, column 68) in decl nil for
	% term generated from main_act_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 690, column 20) in decl nil for
	% term generated from main_act_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 691, column 48) in decl nil for
	% term generated from main_act_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 691, column 81) in decl nil for
	% term generated from main_act_printer  d - 1
	% expected type  device[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 691, column 61) in decl nil for
	% term generated from main_act_printer
	%  main_act_printer(l, d - 1)
	% The disjointness TCC (at line 687, column 3) in decl nil for
	% term generated from main_act_printer
	%  COND d = 0 ->
	%        IF l(d) /= emptyset
	%          THEN concat(concat(concat("device(", real2str(d)), ") := "),
	%                      action_ids2string(l(d)))
	%        ELSE ""
	%        ENDIF,
	%      d > 0 ->
	%        IF l(d) /= emptyset
	%          THEN concat(concat(concat(concat
	%                                    (concat("device(", real2str(d)),
	%                                     ") := "),
	%                                    action_ids2string(l(d))),
	%                             space),
	%                      main_act_printer(l, d - 1))
	%        ELSE main_act_printer(l, d - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 687, column 3) in decl nil for
	% term generated from main_act_printer
	%  COND d = 0 ->
	%        IF l(d) /= emptyset
	%          THEN concat(concat(concat("device(", real2str(d)), ") := "),
	%                      action_ids2string(l(d)))
	%        ELSE ""
	%        ENDIF,
	%      d > 0 ->
	%        IF l(d) /= emptyset
	%          THEN concat(concat(concat(concat
	%                                    (concat("device(", real2str(d)),
	%                                     ") := "),
	%                                    action_ids2string(l(d))),
	%                             space),
	%                      main_act_printer(l, d - 1))
	%        ELSE main_act_printer(l, d - 1)
	%        ENDIF
	% ENDCOND
	% The subtype TCC (at line 698, column 20) in decl nil for
	% term generated from main_enum_par_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 698, column 80) in decl nil for
	% term generated from main_enum_par_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 700, column 20) in decl nil for
	% term generated from main_enum_par_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 701, column 48) in decl nil for
	% term generated from main_enum_par_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 701, column 86) in decl nil for
	% term generated from main_enum_par_printer  d - 1
	% expected type  device[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 701, column 61) in decl nil for
	% term generated from main_enum_par_printer
	%  main_enum_par_printer(l, d - 1)
	% The disjointness TCC (at line 697, column 3) in decl nil for
	% term generated from main_enum_par_printer
	%  COND d = 0 ->
	%        IF l(d) /= empty_enum_parameter
	%          THEN concat(concat(concat("device(", real2str(d)), ") := "),
	%                      enum_parameter2string(l(d)))
	%        ELSE ""
	%        ENDIF,
	%      d > 0 ->
	%        IF l(d) /= empty_enum_parameter
	%          THEN concat(concat(concat(concat
	%                                    (concat("device(", real2str(d)),
	%                                     ") := "),
	%                                    enum_parameter2string(l(d))),
	%                             space),
	%                      main_enum_par_printer(l, d - 1))
	%        ELSE main_enum_par_printer(l, d - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 697, column 3) in decl nil for
	% term generated from main_enum_par_printer
	%  COND d = 0 ->
	%        IF l(d) /= empty_enum_parameter
	%          THEN concat(concat(concat("device(", real2str(d)), ") := "),
	%                      enum_parameter2string(l(d)))
	%        ELSE ""
	%        ENDIF,
	%      d > 0 ->
	%        IF l(d) /= empty_enum_parameter
	%          THEN concat(concat(concat(concat
	%                                    (concat("device(", real2str(d)),
	%                                     ") := "),
	%                                    enum_parameter2string(l(d))),
	%                             space),
	%                      main_enum_par_printer(l, d - 1))
	%        ELSE main_enum_par_printer(l, d - 1)
	%        ENDIF
	% ENDCOND
	% The subtype TCC (at line 708, column 20) in decl nil for
	% term generated from main_num_par_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 709, column 37) in decl nil for
	% term generated from main_num_par_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 711, column 20) in decl nil for
	% term generated from main_num_par_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 712, column 48) in decl nil for
	% term generated from main_num_par_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 712, column 85) in decl nil for
	% term generated from main_num_par_printer  d - 1
	% expected type  device[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 712, column 61) in decl nil for
	% term generated from main_num_par_printer
	%  main_num_par_printer(l, d - 1)
	% The disjointness TCC (at line 707, column 3) in decl nil for
	% term generated from main_num_par_printer
	%  COND d = 0 ->
	%        IF l(d) /= empty_num_parameter
	%          THEN concat(concat(concat("device(", real2str(d)), ") := "),
	%                      num_parameter2string(l(d)))
	%        ELSE ""
	%        ENDIF,
	%      d > 0 ->
	%        IF l(d) /= empty_num_parameter
	%          THEN concat(concat(concat(concat
	%                                    (concat("device(", real2str(d)),
	%                                     ") := "),
	%                                    num_parameter2string(l(d))),
	%                             space),
	%                      main_num_par_printer(l, d - 1))
	%        ELSE main_num_par_printer(l, d - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 707, column 3) in decl nil for
	% term generated from main_num_par_printer
	%  COND d = 0 ->
	%        IF l(d) /= empty_num_parameter
	%          THEN concat(concat(concat("device(", real2str(d)), ") := "),
	%                      num_parameter2string(l(d)))
	%        ELSE ""
	%        ENDIF,
	%      d > 0 ->
	%        IF l(d) /= empty_num_parameter
	%          THEN concat(concat(concat(concat
	%                                    (concat("device(", real2str(d)),
	%                                     ") := "),
	%                                    num_parameter2string(l(d))),
	%                             space),
	%                      main_num_par_printer(l, d - 1))
	%        ELSE main_num_par_printer(l, d - 1)
	%        ENDIF
	% ENDCOND
	% Subtype TCC generated (at line 728, column 29) for  mep
	% expected type  [upto(dlimit) -> enum_parameter]
	  % proved
	main_enum_par2string_TCC1: OBLIGATION
	FORALL (x: nat): x <= nlimit IFF x <= dlimit
	
	% The subtype TCC (at line 605, column 26) in decl nil for
	 % term generated from pan_buff_type2string  pb
	    % expected type  [upto(mindex) ->
	                   %    pan_message_type[maxrate, maxinfuse, maxtime]]
	  % is subsumed by act_buff_type2string_TCC1
	% The subtype TCC (at line 605, column 30) in decl nil for
	 % term generated from pan_buff_type2string  mindex
	    % expected type  index[maxrate, maxinfuse, maxtime]
	  % is subsumed by act_buff_type2string_TCC2
	% The subtype TCC (at line 647, column 20) in decl nil for
	 % term generated from pan_msg_waiting_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC1
	% The subtype TCC (at line 647, column 74) in decl nil for
	 % term generated from pan_msg_waiting_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC1
	% The subtype TCC (at line 649, column 20) in decl nil for
	 % term generated from pan_msg_waiting_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC2
	% The subtype TCC (at line 650, column 46) in decl nil for
	 % term generated from pan_msg_waiting_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC2
	% The subtype TCC (at line 650, column 86) in decl nil for
	 % term generated from pan_msg_waiting_printer  n - 1
	    % expected type  node[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 650, column 59) in decl nil for
	 % term generated from pan_msg_waiting_printer
	    %  pan_msg_waiting_printer(l, n - 1)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 646, column 1) in decl nil for
	 % term generated from pan_msg_waiting_printer
	    %  COND n = 0 ->
	    %        IF l(n)`buf_status /= empty
	    %          THEN concat(concat(concat(concat("node(", real2str(n)),
	    %                                    ") := "),
	    %                             pan_q_type2string(l(n))),
	    %                      newline)
	    %        ELSE ""
	    %        ENDIF,
	    %      n > 0 ->
	    %        IF l(n)`buf_status /= empty
	    %          THEN concat(concat(concat(concat
	    %                                    (concat
	    %                                     (concat("node(", real2str(n)),
	    %                                      ") := "),
	    %                                     pan_q_type2string(l(n))),
	    %                                    space),
	    %                             pan_msg_waiting_printer(l, n - 1)),
	    %                      newline)
	    %        ELSE pan_msg_waiting_printer(l, n - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 646, column 1) in decl nil for
	 % term generated from pan_msg_waiting_printer
	    %  COND n = 0 ->
	    %        IF l(n)`buf_status /= empty
	    %          THEN concat(concat(concat(concat("node(", real2str(n)),
	    %                                    ") := "),
	    %                             pan_q_type2string(l(n))),
	    %                      newline)
	    %        ELSE ""
	    %        ENDIF,
	    %      n > 0 ->
	    %        IF l(n)`buf_status /= empty
	    %          THEN concat(concat(concat(concat
	    %                                    (concat
	    %                                     (concat("node(", real2str(n)),
	    %                                      ") := "),
	    %                                     pan_q_type2string(l(n))),
	    %                                    space),
	    %                             pan_msg_waiting_printer(l, n - 1)),
	    %                      newline)
	    %        ELSE pan_msg_waiting_printer(l, n - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	% The subtype TCC (at line 657, column 20) in decl nil for
	 % term generated from act_msg_waiting_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC1
	% The subtype TCC (at line 657, column 74) in decl nil for
	 % term generated from act_msg_waiting_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC1
	% The subtype TCC (at line 659, column 20) in decl nil for
	 % term generated from act_msg_waiting_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC2
	% The subtype TCC (at line 660, column 46) in decl nil for
	 % term generated from act_msg_waiting_printer  n
	    % expected type  upto(nlimit)
	  % is subsumed by node_printer_bool_TCC2
	% The subtype TCC (at line 660, column 86) in decl nil for
	 % term generated from act_msg_waiting_printer  n - 1
	    % expected type  node[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 660, column 59) in decl nil for
	 % term generated from act_msg_waiting_printer
	    %  act_msg_waiting_printer(l, n - 1)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 656, column 1) in decl nil for
	 % term generated from act_msg_waiting_printer
	    %  COND n = 0 ->
	    %        IF l(n)`buf_status /= empty
	    %          THEN concat(concat(concat(concat("node(", real2str(n)),
	    %                                    ") := "),
	    %                             act_q_type2string(l(n))),
	    %                      newline)
	    %        ELSE ""
	    %        ENDIF,
	    %      n > 0 ->
	    %        IF l(n)`buf_status /= empty
	    %          THEN concat(concat(concat(concat
	    %                                    (concat
	    %                                     (concat("node(", real2str(n)),
	    %                                      ") := "),
	    %                                     act_q_type2string(l(n))),
	    %                                    space),
	    %                             act_msg_waiting_printer(l, n - 1)),
	    %                      newline)
	    %        ELSE act_msg_waiting_printer(l, n - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 656, column 1) in decl nil for
	 % term generated from act_msg_waiting_printer
	    %  COND n = 0 ->
	    %        IF l(n)`buf_status /= empty
	    %          THEN concat(concat(concat(concat("node(", real2str(n)),
	    %                                    ") := "),
	    %                             act_q_type2string(l(n))),
	    %                      newline)
	    %        ELSE ""
	    %        ENDIF,
	    %      n > 0 ->
	    %        IF l(n)`buf_status /= empty
	    %          THEN concat(concat(concat(concat
	    %                                    (concat
	    %                                     (concat("node(", real2str(n)),
	    %                                      ") := "),
	    %                                     act_q_type2string(l(n))),
	    %                                    space),
	    %                             act_msg_waiting_printer(l, n - 1)),
	    %                      newline)
	    %        ELSE act_msg_waiting_printer(l, n - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	% The subtype TCC (at line 668, column 13) in decl nil for
	 % term generated from d_panel_type_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC1
	% The subtype TCC (at line 668, column 67) in decl nil for
	 % term generated from d_panel_type_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC1
	% The subtype TCC (at line 670, column 13) in decl nil for
	 % term generated from d_panel_type_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC2
	% The subtype TCC (at line 671, column 42) in decl nil for
	 % term generated from d_panel_type_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC2
	% The subtype TCC (at line 671, column 71) in decl nil for
	 % term generated from d_panel_type_printer  d - 1
	    % expected type  device[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 671, column 47) in decl nil for
	 % term generated from d_panel_type_printer
	    %  d_panel_type_printer(l, d - 1)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 666, column 1) in decl nil for
	 % term generated from d_panel_type_printer
	    %  COND d = 0 ->
	    %        IF l(d)`pars /= emptyset
	    %          THEN concat(concat(concat(" device(", real2str(d)),
	    %                             ") := "),
	    %                      panel2string(l(d)))
	    %        ELSE ""
	    %        ENDIF,
	    %      d > 0 ->
	    %        IF l(d)`pars /= emptyset
	    %          THEN concat(concat(concat(concat(" device(", real2str(d)),
	    %                                    ") := "),
	    %                             panel2string(l(d))),
	    %                      d_panel_type_printer(l, d - 1))
	    %        ELSE d_panel_type_printer(l, d - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 666, column 1) in decl nil for
	 % term generated from d_panel_type_printer
	    %  COND d = 0 ->
	    %        IF l(d)`pars /= emptyset
	    %          THEN concat(concat(concat(" device(", real2str(d)),
	    %                             ") := "),
	    %                      panel2string(l(d)))
	    %        ELSE ""
	    %        ENDIF,
	    %      d > 0 ->
	    %        IF l(d)`pars /= emptyset
	    %          THEN concat(concat(concat(concat(" device(", real2str(d)),
	    %                                    ") := "),
	    %                             panel2string(l(d))),
	    %                      d_panel_type_printer(l, d - 1))
	    %        ELSE d_panel_type_printer(l, d - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	% The subtype TCC (at line 678, column 20) in decl nil for
	 % term generated from p_dstates_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC1
	% The subtype TCC (at line 678, column 71) in decl nil for
	 % term generated from p_dstates_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC1
	% The subtype TCC (at line 680, column 20) in decl nil for
	 % term generated from p_dstates_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC2
	% The subtype TCC (at line 681, column 48) in decl nil for
	 % term generated from p_dstates_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC2
	% The subtype TCC (at line 681, column 82) in decl nil for
	 % term generated from p_dstates_printer  d - 1
	    % expected type  device[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 681, column 61) in decl nil for
	 % term generated from p_dstates_printer
	    %  p_dstates_printer(l, d - 1)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 677, column 3) in decl nil for
	 % term generated from p_dstates_printer
	    %  COND d = 0 ->
	    %        IF l(d)`nde /= no_node
	    %          THEN concat(concat(concat("device(", real2str(d)), ") := "),
	    %                      d_state2string(l(d)))
	    %        ELSE ""
	    %        ENDIF,
	    %      d > 0 ->
	    %        IF l(d)`nde /= no_node
	    %          THEN concat(concat(concat(concat
	    %                                    (concat("device(", real2str(d)),
	    %                                     ") := "),
	    %                                    d_state2string(l(d))),
	    %                             space),
	    %                      p_dstates_printer(l, d - 1))
	    %        ELSE p_dstates_printer(l, d - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 677, column 3) in decl nil for
	 % term generated from p_dstates_printer
	    %  COND d = 0 ->
	    %        IF l(d)`nde /= no_node
	    %          THEN concat(concat(concat("device(", real2str(d)), ") := "),
	    %                      d_state2string(l(d)))
	    %        ELSE ""
	    %        ENDIF,
	    %      d > 0 ->
	    %        IF l(d)`nde /= no_node
	    %          THEN concat(concat(concat(concat
	    %                                    (concat("device(", real2str(d)),
	    %                                     ") := "),
	    %                                    d_state2string(l(d))),
	    %                             space),
	    %                      p_dstates_printer(l, d - 1))
	    %        ELSE p_dstates_printer(l, d - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	% The subtype TCC (at line 688, column 20) in decl nil for
	 % term generated from main_act_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC1
	% The subtype TCC (at line 688, column 68) in decl nil for
	 % term generated from main_act_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC1
	% The subtype TCC (at line 690, column 20) in decl nil for
	 % term generated from main_act_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC2
	% The subtype TCC (at line 691, column 48) in decl nil for
	 % term generated from main_act_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC2
	% The subtype TCC (at line 691, column 81) in decl nil for
	 % term generated from main_act_printer  d - 1
	    % expected type  device[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 691, column 61) in decl nil for
	 % term generated from main_act_printer
	    %  main_act_printer(l, d - 1)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 687, column 3) in decl nil for
	 % term generated from main_act_printer
	    %  COND d = 0 ->
	    %        IF l(d) /= emptyset
	    %          THEN concat(concat(concat("device(", real2str(d)), ") := "),
	    %                      action_ids2string(l(d)))
	    %        ELSE ""
	    %        ENDIF,
	    %      d > 0 ->
	    %        IF l(d) /= emptyset
	    %          THEN concat(concat(concat(concat
	    %                                    (concat("device(", real2str(d)),
	    %                                     ") := "),
	    %                                    action_ids2string(l(d))),
	    %                             space),
	    %                      main_act_printer(l, d - 1))
	    %        ELSE main_act_printer(l, d - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 687, column 3) in decl nil for
	 % term generated from main_act_printer
	    %  COND d = 0 ->
	    %        IF l(d) /= emptyset
	    %          THEN concat(concat(concat("device(", real2str(d)), ") := "),
	    %                      action_ids2string(l(d)))
	    %        ELSE ""
	    %        ENDIF,
	    %      d > 0 ->
	    %        IF l(d) /= emptyset
	    %          THEN concat(concat(concat(concat
	    %                                    (concat("device(", real2str(d)),
	    %                                     ") := "),
	    %                                    action_ids2string(l(d))),
	    %                             space),
	    %                      main_act_printer(l, d - 1))
	    %        ELSE main_act_printer(l, d - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	% The subtype TCC (at line 698, column 20) in decl nil for
	 % term generated from main_enum_par_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC1
	% The subtype TCC (at line 698, column 80) in decl nil for
	 % term generated from main_enum_par_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC1
	% The subtype TCC (at line 700, column 20) in decl nil for
	 % term generated from main_enum_par_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC2
	% The subtype TCC (at line 701, column 48) in decl nil for
	 % term generated from main_enum_par_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC2
	% The subtype TCC (at line 701, column 86) in decl nil for
	 % term generated from main_enum_par_printer  d - 1
	    % expected type  device[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 701, column 61) in decl nil for
	 % term generated from main_enum_par_printer
	    %  main_enum_par_printer(l, d - 1)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 697, column 3) in decl nil for
	 % term generated from main_enum_par_printer
	    %  COND d = 0 ->
	    %        IF l(d) /= empty_enum_parameter
	    %          THEN concat(concat(concat("device(", real2str(d)), ") := "),
	    %                      enum_parameter2string(l(d)))
	    %        ELSE ""
	    %        ENDIF,
	    %      d > 0 ->
	    %        IF l(d) /= empty_enum_parameter
	    %          THEN concat(concat(concat(concat
	    %                                    (concat("device(", real2str(d)),
	    %                                     ") := "),
	    %                                    enum_parameter2string(l(d))),
	    %                             space),
	    %                      main_enum_par_printer(l, d - 1))
	    %        ELSE main_enum_par_printer(l, d - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 697, column 3) in decl nil for
	 % term generated from main_enum_par_printer
	    %  COND d = 0 ->
	    %        IF l(d) /= empty_enum_parameter
	    %          THEN concat(concat(concat("device(", real2str(d)), ") := "),
	    %                      enum_parameter2string(l(d)))
	    %        ELSE ""
	    %        ENDIF,
	    %      d > 0 ->
	    %        IF l(d) /= empty_enum_parameter
	    %          THEN concat(concat(concat(concat
	    %                                    (concat("device(", real2str(d)),
	    %                                     ") := "),
	    %                                    enum_parameter2string(l(d))),
	    %                             space),
	    %                      main_enum_par_printer(l, d - 1))
	    %        ELSE main_enum_par_printer(l, d - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	% The subtype TCC (at line 708, column 20) in decl nil for
	 % term generated from main_num_par_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC1
	% The subtype TCC (at line 709, column 37) in decl nil for
	 % term generated from main_num_par_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC1
	% The subtype TCC (at line 711, column 20) in decl nil for
	 % term generated from main_num_par_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC2
	% The subtype TCC (at line 712, column 48) in decl nil for
	 % term generated from main_num_par_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC2
	% The subtype TCC (at line 712, column 85) in decl nil for
	 % term generated from main_num_par_printer  d - 1
	    % expected type  device[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 712, column 61) in decl nil for
	 % term generated from main_num_par_printer
	    %  main_num_par_printer(l, d - 1)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 707, column 3) in decl nil for
	 % term generated from main_num_par_printer
	    %  COND d = 0 ->
	    %        IF l(d) /= empty_num_parameter
	    %          THEN concat(concat(concat("device(", real2str(d)), ") := "),
	    %                      num_parameter2string(l(d)))
	    %        ELSE ""
	    %        ENDIF,
	    %      d > 0 ->
	    %        IF l(d) /= empty_num_parameter
	    %          THEN concat(concat(concat(concat
	    %                                    (concat("device(", real2str(d)),
	    %                                     ") := "),
	    %                                    num_parameter2string(l(d))),
	    %                             space),
	    %                      main_num_par_printer(l, d - 1))
	    %        ELSE main_num_par_printer(l, d - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 707, column 3) in decl nil for
	 % term generated from main_num_par_printer
	    %  COND d = 0 ->
	    %        IF l(d) /= empty_num_parameter
	    %          THEN concat(concat(concat("device(", real2str(d)), ") := "),
	    %                      num_parameter2string(l(d)))
	    %        ELSE ""
	    %        ENDIF,
	    %      d > 0 ->
	    %        IF l(d) /= empty_num_parameter
	    %          THEN concat(concat(concat(concat
	    %                                    (concat("device(", real2str(d)),
	    %                                     ") := "),
	    %                                    num_parameter2string(l(d))),
	    %                             space),
	    %                      main_num_par_printer(l, d - 1))
	    %        ELSE main_num_par_printer(l, d - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	
	% The subtype TCC (at line 728, column 34) in decl nil for
	% term generated from main_enum_par2string  dlimit
	% expected type  device[maxrate, maxinfuse, maxtime]
	% The subtype TCC (at line 733, column 20) in decl nil for
	% term generated from action_error_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 733, column 75) in decl nil for
	% term generated from action_error_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 735, column 20) in decl nil for
	% term generated from action_error_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 735, column 75) in decl nil for
	% term generated from action_error_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 736, column 40) in decl nil for
	% term generated from action_error_printer  p - 1
	% expected type  patient[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 736, column 16) in decl nil for
	% term generated from action_error_printer
	%  action_error_printer(l, p - 1)
	% The disjointness TCC (at line 732, column 3) in decl nil for
	% term generated from action_error_printer
	%  COND p = 0 ->
	%        IF l(p)`dev /= nil_device
	%          THEN concat(concat(concat("patient(", real2str(p)),
	%                             ") := "),
	%                      dev_act_type2string(l(p)))
	%        ELSE ""
	%        ENDIF,
	%      p > 0 ->
	%        IF l(p)`dev /= nil_device
	%          THEN concat(concat(concat(concat
	%                                    (concat("patient(", real2str(p)),
	%                                     ") := "),
	%                                    dev_act_type2string(l(p))),
	%                             space),
	%                      action_error_printer(l, p - 1))
	%        ELSE action_error_printer(l, p - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 732, column 3) in decl nil for
	% term generated from action_error_printer
	%  COND p = 0 ->
	%        IF l(p)`dev /= nil_device
	%          THEN concat(concat(concat("patient(", real2str(p)),
	%                             ") := "),
	%                      dev_act_type2string(l(p)))
	%        ELSE ""
	%        ENDIF,
	%      p > 0 ->
	%        IF l(p)`dev /= nil_device
	%          THEN concat(concat(concat(concat
	%                                    (concat("patient(", real2str(p)),
	%                                     ") := "),
	%                                    dev_act_type2string(l(p))),
	%                             space),
	%                      action_error_printer(l, p - 1))
	%        ELSE action_error_printer(l, p - 1)
	%        ENDIF
	% ENDCOND
	% Subtype TCC generated (at line 741, column 28) for  aet
	% expected type  [upto(plimit) ->
	%    dev_act_type[maxrate, maxinfuse, maxtime]]
	  % proved
	action_error_type2string_TCC1: OBLIGATION
	FORALL (x: nat): x <= nlimit IFF x <= plimit
	
	% The subtype TCC (at line 728, column 34) in decl nil for
	 % term generated from main_enum_par2string  dlimit
	    % expected type  device[maxrate, maxinfuse, maxtime]
	  % is subsumed by devices2string_TCC2
	% The subtype TCC (at line 733, column 20) in decl nil for
	 % term generated from action_error_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC1
	% The subtype TCC (at line 733, column 75) in decl nil for
	 % term generated from action_error_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC1
	% The subtype TCC (at line 735, column 20) in decl nil for
	 % term generated from action_error_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC2
	% The subtype TCC (at line 735, column 75) in decl nil for
	 % term generated from action_error_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC2
	% The subtype TCC (at line 736, column 40) in decl nil for
	 % term generated from action_error_printer  p - 1
	    % expected type  patient[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 736, column 16) in decl nil for
	 % term generated from action_error_printer
	    %  action_error_printer(l, p - 1)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 732, column 3) in decl nil for
	 % term generated from action_error_printer
	    %  COND p = 0 ->
	    %        IF l(p)`dev /= nil_device
	    %          THEN concat(concat(concat("patient(", real2str(p)),
	    %                             ") := "),
	    %                      dev_act_type2string(l(p)))
	    %        ELSE ""
	    %        ENDIF,
	    %      p > 0 ->
	    %        IF l(p)`dev /= nil_device
	    %          THEN concat(concat(concat(concat
	    %                                    (concat("patient(", real2str(p)),
	    %                                     ") := "),
	    %                                    dev_act_type2string(l(p))),
	    %                             space),
	    %                      action_error_printer(l, p - 1))
	    %        ELSE action_error_printer(l, p - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 732, column 3) in decl nil for
	 % term generated from action_error_printer
	    %  COND p = 0 ->
	    %        IF l(p)`dev /= nil_device
	    %          THEN concat(concat(concat("patient(", real2str(p)),
	    %                             ") := "),
	    %                      dev_act_type2string(l(p)))
	    %        ELSE ""
	    %        ENDIF,
	    %      p > 0 ->
	    %        IF l(p)`dev /= nil_device
	    %          THEN concat(concat(concat(concat
	    %                                    (concat("patient(", real2str(p)),
	    %                                     ") := "),
	    %                                    dev_act_type2string(l(p))),
	    %                             space),
	    %                      action_error_printer(l, p - 1))
	    %        ELSE action_error_printer(l, p - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	
	% The subtype TCC (at line 741, column 33) in decl nil for
	% term generated from action_error_type2string  plimit
	% expected type  patient[maxrate, maxinfuse, maxtime]
	% The subtype TCC (at line 746, column 44) in decl nil for
	% term generated from top_enum_par_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 747, column 44) in decl nil for
	% term generated from top_enum_par_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 747, column 81) in decl nil for
	% term generated from top_enum_par_printer  p - 1
	% expected type  patient[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 747, column 57) in decl nil for
	% term generated from top_enum_par_printer
	%  top_enum_par_printer(l, p - 1)
	% The disjointness TCC (at line 745, column 3) in decl nil for
	% term generated from top_enum_par_printer
	%  COND p = 0 ->
	%        concat(concat(concat("patient(", real2str(p)), ") := "),
	%               main_enum_par2string(l(p))),
	%      p > 0 ->
	%        concat(concat(concat(concat(concat("patient(", real2str(p)),
	%                                    ") := "),
	%                             main_enum_par2string(l(p))),
	%                      space),
	%               top_enum_par_printer(l, p - 1))
	% ENDCOND
	% The coverage TCC (at line 745, column 3) in decl nil for
	% term generated from top_enum_par_printer
	%  COND p = 0 ->
	%        concat(concat(concat("patient(", real2str(p)), ") := "),
	%               main_enum_par2string(l(p))),
	%      p > 0 ->
	%        concat(concat(concat(concat(concat("patient(", real2str(p)),
	%                                    ") := "),
	%                             main_enum_par2string(l(p))),
	%                      space),
	%               top_enum_par_printer(l, p - 1))
	% ENDCOND
	% Subtype TCC generated (at line 752, column 33) for  6
	% expected type  patient[maxrate, maxinfuse, maxtime]
	  % proved
	top_enum_params2string_TCC1: OBLIGATION
	6 <= nlimit
	
	% The subtype TCC (at line 741, column 33) in decl nil for
	 % term generated from action_error_type2string  plimit
	    % expected type  patient[maxrate, maxinfuse, maxtime]
	  % is subsumed by patients_type2string_TCC2
	% The subtype TCC (at line 746, column 44) in decl nil for
	 % term generated from top_enum_par_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC1
	% The subtype TCC (at line 747, column 44) in decl nil for
	 % term generated from top_enum_par_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC2
	% The subtype TCC (at line 747, column 81) in decl nil for
	 % term generated from top_enum_par_printer  p - 1
	    % expected type  patient[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 747, column 57) in decl nil for
	 % term generated from top_enum_par_printer
	    %  top_enum_par_printer(l, p - 1)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 745, column 3) in decl nil for
	 % term generated from top_enum_par_printer
	    %  COND p = 0 ->
	    %        concat(concat(concat("patient(", real2str(p)), ") := "),
	    %               main_enum_par2string(l(p))),
	    %      p > 0 ->
	    %        concat(concat(concat(concat(concat("patient(", real2str(p)),
	    %                                    ") := "),
	    %                             main_enum_par2string(l(p))),
	    %                      space),
	    %               top_enum_par_printer(l, p - 1))
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 745, column 3) in decl nil for
	 % term generated from top_enum_par_printer
	    %  COND p = 0 ->
	    %        concat(concat(concat("patient(", real2str(p)), ") := "),
	    %               main_enum_par2string(l(p))),
	    %      p > 0 ->
	    %        concat(concat(concat(concat(concat("patient(", real2str(p)),
	    %                                    ") := "),
	    %                             main_enum_par2string(l(p))),
	    %                      space),
	    %               top_enum_par_printer(l, p - 1))
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	
	% The subtype TCC (at line 752, column 28) in decl nil for
	% term generated from top_enum_params2string  tep
	% expected type  [upto(plimit) ->
	%    main_enum_par[maxrate, maxinfuse, maxtime]]
	% The subtype TCC (at line 756, column 28) in decl nil for
	% term generated from main_num_par2string  mnp
	% expected type  [upto(dlimit) -> num_parameter]
	% The subtype TCC (at line 756, column 33) in decl nil for
	% term generated from main_num_par2string  dlimit
	% expected type  device[maxrate, maxinfuse, maxtime]
	% The subtype TCC (at line 761, column 44) in decl nil for
	% term generated from top_num_par_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 762, column 44) in decl nil for
	% term generated from top_num_par_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 762, column 80) in decl nil for
	% term generated from top_num_par_printer  p - 1
	% expected type  patient[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 762, column 57) in decl nil for
	% term generated from top_num_par_printer
	%  top_num_par_printer(l, p - 1)
	% The disjointness TCC (at line 760, column 3) in decl nil for
	% term generated from top_num_par_printer
	%  COND p = 0 ->
	%        concat(concat(concat("patient(", real2str(p)), ") := "),
	%               main_num_par2string(l(p))),
	%      p > 0 ->
	%        concat(concat(concat(concat(concat("patient(", real2str(p)),
	%                                    ") := "),
	%                             main_num_par2string(l(p))),
	%                      space),
	%               top_num_par_printer(l, p - 1))
	% ENDCOND
	% The coverage TCC (at line 760, column 3) in decl nil for
	% term generated from top_num_par_printer
	%  COND p = 0 ->
	%        concat(concat(concat("patient(", real2str(p)), ") := "),
	%               main_num_par2string(l(p))),
	%      p > 0 ->
	%        concat(concat(concat(concat(concat("patient(", real2str(p)),
	%                                    ") := "),
	%                             main_num_par2string(l(p))),
	%                      space),
	%               top_num_par_printer(l, p - 1))
	% ENDCOND
	% The subtype TCC (at line 767, column 27) in decl nil for
	% term generated from top_num_params2string  tep
	% expected type  [upto(plimit) ->
	%    main_num_par[maxrate, maxinfuse, maxtime]]
	% The subtype TCC (at line 767, column 32) in decl nil for
	% term generated from top_num_params2string  6
	% expected type  patient[maxrate, maxinfuse, maxtime]
	% The subtype TCC (at line 771, column 24) in decl nil for
	% term generated from main_act2string  ma
	% expected type  [upto(dlimit) -> action_ids]
	% The subtype TCC (at line 771, column 28) in decl nil for
	% term generated from main_act2string  dlimit
	% expected type  device[maxrate, maxinfuse, maxtime]
	% The subtype TCC (at line 775, column 28) in decl nil for
	% term generated from dpanel_type2string  dp
	% expected type  [upto(dlimit) -> panel]
	% The subtype TCC (at line 775, column 32) in decl nil for
	% term generated from dpanel_type2string  dlimit
	% expected type  device[maxrate, maxinfuse, maxtime]
	% Subtype TCC generated (at line 792, column 33) for  1
	% expected type  device[maxrate, maxinfuse, maxtime]
	  % proved
	coord_db_printer_TCC1: OBLIGATION
	FORALL (p: patient[maxrate, maxinfuse, maxtime]): p = 0 IMPLIES 1 <= nlimit
	
	% The subtype TCC (at line 752, column 28) in decl nil for
	 % term generated from top_enum_params2string  tep
	    % expected type  [upto(plimit) ->
	                   %    main_enum_par[maxrate, maxinfuse, maxtime]]
	  % is subsumed by action_error_type2string_TCC1
	% The subtype TCC (at line 756, column 28) in decl nil for
	 % term generated from main_num_par2string  mnp
	    % expected type  [upto(dlimit) -> num_parameter]
	  % is subsumed by main_enum_par2string_TCC1
	% The subtype TCC (at line 756, column 33) in decl nil for
	 % term generated from main_num_par2string  dlimit
	    % expected type  device[maxrate, maxinfuse, maxtime]
	  % is subsumed by devices2string_TCC2
	% The subtype TCC (at line 761, column 44) in decl nil for
	 % term generated from top_num_par_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC1
	% The subtype TCC (at line 762, column 44) in decl nil for
	 % term generated from top_num_par_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC2
	% The subtype TCC (at line 762, column 80) in decl nil for
	 % term generated from top_num_par_printer  p - 1
	    % expected type  patient[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 762, column 57) in decl nil for
	 % term generated from top_num_par_printer
	    %  top_num_par_printer(l, p - 1)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 760, column 3) in decl nil for
	 % term generated from top_num_par_printer
	    %  COND p = 0 ->
	    %        concat(concat(concat("patient(", real2str(p)), ") := "),
	    %               main_num_par2string(l(p))),
	    %      p > 0 ->
	    %        concat(concat(concat(concat(concat("patient(", real2str(p)),
	    %                                    ") := "),
	    %                             main_num_par2string(l(p))),
	    %                      space),
	    %               top_num_par_printer(l, p - 1))
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 760, column 3) in decl nil for
	 % term generated from top_num_par_printer
	    %  COND p = 0 ->
	    %        concat(concat(concat("patient(", real2str(p)), ") := "),
	    %               main_num_par2string(l(p))),
	    %      p > 0 ->
	    %        concat(concat(concat(concat(concat("patient(", real2str(p)),
	    %                                    ") := "),
	    %                             main_num_par2string(l(p))),
	    %                      space),
	    %               top_num_par_printer(l, p - 1))
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	% The subtype TCC (at line 767, column 27) in decl nil for
	 % term generated from top_num_params2string  tep
	    % expected type  [upto(plimit) ->
	                   %    main_num_par[maxrate, maxinfuse, maxtime]]
	  % is subsumed by action_error_type2string_TCC1
	% The subtype TCC (at line 767, column 32) in decl nil for
	 % term generated from top_num_params2string  6
	    % expected type  patient[maxrate, maxinfuse, maxtime]
	  % is subsumed by top_enum_params2string_TCC1
	% The subtype TCC (at line 771, column 24) in decl nil for
	 % term generated from main_act2string  ma
	    % expected type  [upto(dlimit) -> action_ids]
	  % is subsumed by main_enum_par2string_TCC1
	% The subtype TCC (at line 771, column 28) in decl nil for
	 % term generated from main_act2string  dlimit
	    % expected type  device[maxrate, maxinfuse, maxtime]
	  % is subsumed by devices2string_TCC2
	% The subtype TCC (at line 775, column 28) in decl nil for
	 % term generated from dpanel_type2string  dp
	    % expected type  [upto(dlimit) -> panel]
	  % is subsumed by main_enum_par2string_TCC1
	% The subtype TCC (at line 775, column 32) in decl nil for
	 % term generated from dpanel_type2string  dlimit
	    % expected type  device[maxrate, maxinfuse, maxtime]
	  % is subsumed by devices2string_TCC2
	
	% Subtype TCC generated (at line 794, column 33) for  1
	% expected type  device[maxrate, maxinfuse, maxtime]
	  % proved
	coord_db_printer_TCC2: OBLIGATION
	FORALL (p: patient[maxrate, maxinfuse, maxtime]): p > 0 IMPLIES 1 <= nlimit
	
	% The subtype TCC (at line 792, column 20) in decl nil for
	% term generated from coord_db_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 792, column 83) in decl nil for
	% term generated from coord_db_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 794, column 20) in decl nil for
	% term generated from coord_db_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 795, column 49) in decl nil for
	% term generated from coord_db_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 795, column 82) in decl nil for
	% term generated from coord_db_printer  p - 1
	% expected type  patient[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 795, column 62) in decl nil for
	% term generated from coord_db_printer
	%  coord_db_printer(l, p - 1)
	% The disjointness TCC (at line 791, column 3) in decl nil for
	% term generated from coord_db_printer
	%  COND p = 0 ->
	%        IF l(p)`p_devices(1) /= no_device
	%          THEN concat(concat(concat(concat("patient(", real2str(p)),
	%                                    ") := "),
	%                             patient_config2string(l(p))),
	%                      newline)
	%        ELSE ""
	%        ENDIF,
	%      p > 0 ->
	%        IF l(p)`p_devices(1) /= no_device
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat("patient(", real2str(p)),
	%                                      ") := "),
	%                                     patient_config2string(l(p))),
	%                                    space),
	%                             coord_db_printer(l, p - 1)),
	%                      newline)
	%        ELSE coord_db_printer(l, p - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 791, column 3) in decl nil for
	% term generated from coord_db_printer
	%  COND p = 0 ->
	%        IF l(p)`p_devices(1) /= no_device
	%          THEN concat(concat(concat(concat("patient(", real2str(p)),
	%                                    ") := "),
	%                             patient_config2string(l(p))),
	%                      newline)
	%        ELSE ""
	%        ENDIF,
	%      p > 0 ->
	%        IF l(p)`p_devices(1) /= no_device
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat("patient(", real2str(p)),
	%                                      ") := "),
	%                                     patient_config2string(l(p))),
	%                                    space),
	%                             coord_db_printer(l, p - 1)),
	%                      newline)
	%        ELSE coord_db_printer(l, p - 1)
	%        ENDIF
	% ENDCOND
	% The subtype TCC (at line 801, column 26) in decl nil for
	% term generated from coord_db_type2string  cd
	% expected type  [upto(plimit) ->
	%    patient_config[maxrate, maxinfuse, maxtime]]
	% The subtype TCC (at line 801, column 30) in decl nil for
	% term generated from coord_db_type2string  plimit
	% expected type  patient[maxrate, maxinfuse, maxtime]
	% The subtype TCC (at line 806, column 33) in decl nil for
	% term generated from pan_msg_waiting_type2string  pw
	% expected type  [upto(nlimit) ->
	%    pan_q_type[maxrate, maxinfuse, maxtime]]
	% The subtype TCC (at line 806, column 37) in decl nil for
	% term generated from pan_msg_waiting_type2string  nlimit
	% expected type  node[maxrate, maxinfuse, maxtime]
	% The subtype TCC (at line 810, column 33) in decl nil for
	% term generated from act_msg_waiting_type2string  aw
	% expected type  [upto(nlimit) ->
	%    act_q_type[maxrate, maxinfuse, maxtime]]
	% The subtype TCC (at line 810, column 37) in decl nil for
	% term generated from act_msg_waiting_type2string  nlimit
	% expected type  node[maxrate, maxinfuse, maxtime]
	% The subtype TCC (at line 849, column 25) in decl nil for
	% term generated from p_dstates2string  pd
	% expected type  [upto(dlimit) -> d_state[maxrate, maxinfuse, maxtime]]
	% The subtype TCC (at line 849, column 29) in decl nil for
	% term generated from p_dstates2string  dlimit
	% expected type  device[maxrate, maxinfuse, maxtime]
	% Subtype TCC generated (at line 932, column 92) for  c - 1
	% expected type  cindex
	  % proved
	production_type_printer_TCC1: OBLIGATION
	FORALL (l: [upto(climit) -> constraint_type[maxrate, maxinfuse, maxtime]],
	          c: cindex):
	    c > 0 AND l(c)`vt /= empty IMPLIES c - 1 >= 0 AND c - 1 <= climit
	
	% The subtype TCC (at line 792, column 20) in decl nil for
	 % term generated from coord_db_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC1
	% The subtype TCC (at line 792, column 83) in decl nil for
	 % term generated from coord_db_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC1
	% The subtype TCC (at line 794, column 20) in decl nil for
	 % term generated from coord_db_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC2
	% The subtype TCC (at line 795, column 49) in decl nil for
	 % term generated from coord_db_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC2
	% The subtype TCC (at line 795, column 82) in decl nil for
	 % term generated from coord_db_printer  p - 1
	    % expected type  patient[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 795, column 62) in decl nil for
	 % term generated from coord_db_printer
	    %  coord_db_printer(l, p - 1)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 791, column 3) in decl nil for
	 % term generated from coord_db_printer
	    %  COND p = 0 ->
	    %        IF l(p)`p_devices(1) /= no_device
	    %          THEN concat(concat(concat(concat("patient(", real2str(p)),
	    %                                    ") := "),
	    %                             patient_config2string(l(p))),
	    %                      newline)
	    %        ELSE ""
	    %        ENDIF,
	    %      p > 0 ->
	    %        IF l(p)`p_devices(1) /= no_device
	    %          THEN concat(concat(concat(concat
	    %                                    (concat
	    %                                     (concat("patient(", real2str(p)),
	    %                                      ") := "),
	    %                                     patient_config2string(l(p))),
	    %                                    space),
	    %                             coord_db_printer(l, p - 1)),
	    %                      newline)
	    %        ELSE coord_db_printer(l, p - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 791, column 3) in decl nil for
	 % term generated from coord_db_printer
	    %  COND p = 0 ->
	    %        IF l(p)`p_devices(1) /= no_device
	    %          THEN concat(concat(concat(concat("patient(", real2str(p)),
	    %                                    ") := "),
	    %                             patient_config2string(l(p))),
	    %                      newline)
	    %        ELSE ""
	    %        ENDIF,
	    %      p > 0 ->
	    %        IF l(p)`p_devices(1) /= no_device
	    %          THEN concat(concat(concat(concat
	    %                                    (concat
	    %                                     (concat("patient(", real2str(p)),
	    %                                      ") := "),
	    %                                     patient_config2string(l(p))),
	    %                                    space),
	    %                             coord_db_printer(l, p - 1)),
	    %                      newline)
	    %        ELSE coord_db_printer(l, p - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	% The subtype TCC (at line 801, column 26) in decl nil for
	 % term generated from coord_db_type2string  cd
	    % expected type  [upto(plimit) ->
	                   %    patient_config[maxrate, maxinfuse, maxtime]]
	  % is subsumed by action_error_type2string_TCC1
	% The subtype TCC (at line 801, column 30) in decl nil for
	 % term generated from coord_db_type2string  plimit
	    % expected type  patient[maxrate, maxinfuse, maxtime]
	  % is subsumed by patients_type2string_TCC2
	% The subtype TCC (at line 806, column 33) in decl nil for
	 % term generated from pan_msg_waiting_type2string  pw
	    % expected type  [upto(nlimit) ->
	                   %    pan_q_type[maxrate, maxinfuse, maxtime]]
	  % is subsumed by connected2string_TCC1
	% The subtype TCC (at line 806, column 37) in decl nil for
	 % term generated from pan_msg_waiting_type2string  nlimit
	    % expected type  node[maxrate, maxinfuse, maxtime]
	  % is subsumed by connected2string_TCC2
	% The subtype TCC (at line 810, column 33) in decl nil for
	 % term generated from act_msg_waiting_type2string  aw
	    % expected type  [upto(nlimit) ->
	                   %    act_q_type[maxrate, maxinfuse, maxtime]]
	  % is subsumed by connected2string_TCC1
	% The subtype TCC (at line 810, column 37) in decl nil for
	 % term generated from act_msg_waiting_type2string  nlimit
	    % expected type  node[maxrate, maxinfuse, maxtime]
	  % is subsumed by connected2string_TCC2
	% The subtype TCC (at line 849, column 25) in decl nil for
	 % term generated from p_dstates2string  pd
	    % expected type  [upto(dlimit) -> d_state[maxrate, maxinfuse, maxtime]]
	  % is subsumed by main_enum_par2string_TCC1
	% The subtype TCC (at line 849, column 29) in decl nil for
	 % term generated from p_dstates2string  dlimit
	    % expected type  device[maxrate, maxinfuse, maxtime]
	  % is subsumed by devices2string_TCC2
	
	% Termination TCC generated (at line 932, column 65) for
	% production_type_printer(l, c - 1)
	  % proved
	production_type_printer_TCC2: OBLIGATION
	FORALL (l: [upto(climit) -> constraint_type[maxrate, maxinfuse, maxtime]],
	          c: cindex):
	    c > 0 AND l(c)`vt /= empty IMPLIES c - 1 < c
	
	% Disjointness TCC generated (at line 928, column 1) for
	% COND c = 0 ->
	%        IF l(c)`vt /= empty
	%          THEN concat(concat(concat(concat
	%                                    ("constraint(", real2str(c)),
	%                                    ") := "),
	%                             constraint_type2string(l(c))),
	%                      newline)
	%        ELSE ""
	%        ENDIF,
	%      c > 0 ->
	%        IF l(c)`vt /= empty
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat
	%                                      ("constraint(", real2str(c)),
	%                                      ") := "),
	%                                     constraint_type2string(l(c))),
	%                                    space),
	%                             production_type_printer(l, c - 1)),
	%                      newline)
	%        ELSE production_type_printer(l, c - 1)
	%        ENDIF
	% ENDCOND
	  % proved
	production_type_printer_TCC3: OBLIGATION
	FORALL (c: cindex): NOT (c = 0 AND c > 0)
	
	% Coverage TCC generated (at line 928, column 1) for
	% COND c = 0 ->
	%        IF l(c)`vt /= empty
	%          THEN concat(concat(concat(concat
	%                                    ("constraint(", real2str(c)),
	%                                    ") := "),
	%                             constraint_type2string(l(c))),
	%                      newline)
	%        ELSE ""
	%        ENDIF,
	%      c > 0 ->
	%        IF l(c)`vt /= empty
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat
	%                                      ("constraint(", real2str(c)),
	%                                      ") := "),
	%                                     constraint_type2string(l(c))),
	%                                    space),
	%                             production_type_printer(l, c - 1)),
	%                      newline)
	%        ELSE production_type_printer(l, c - 1)
	%        ENDIF
	% ENDCOND
	  % proved
	production_type_printer_TCC4: OBLIGATION
	FORALL (c: cindex): c = 0 OR c > 0
	
	% Subtype TCC generated (at line 938, column 35) for  climit
	% expected type  cindex
	  % proved
	production_type2string_TCC1: OBLIGATION
	climit <= climit
	
	% Subtype TCC generated (at line 952, column 89) for  c - 1
	% expected type  cindex
	  % proved
	patient_constraint_printer_TCC1: OBLIGATION
	FORALL (l: [upto(climit) -> rule_type[maxrate, maxinfuse, maxtime]],
	          c: cindex):
	    c > 0 AND (l(c)`action)`act /= nil_action IMPLIES
	     c - 1 >= 0 AND c - 1 <= climit
	
	% Termination TCC generated (at line 952, column 59) for
	% patient_constraint_printer(l, c - 1)
	  % proved
	patient_constraint_printer_TCC2: OBLIGATION
	FORALL (l: [upto(climit) -> rule_type[maxrate, maxinfuse, maxtime]],
	          c: cindex):
	    c > 0 AND (l(c)`action)`act /= nil_action IMPLIES c - 1 < c
	
	% The disjointness TCC (at line 948, column 1) in decl nil for
	% term generated from patient_constraint_printer
	%  COND c = 0 ->
	%        IF (l(c)`action)`act /= nil_action
	%          THEN concat(concat(concat(concat("rule(", real2str(c)),
	%                                    ") := "),
	%                             rule_type2string(l(c))),
	%                      newline)
	%        ELSE ""
	%        ENDIF,
	%      c > 0 ->
	%        IF (l(c)`action)`act /= nil_action
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat("rule(", real2str(c)),
	%                                      ") := "),
	%                                     rule_type2string(l(c))),
	%                                    space),
	%                             patient_constraint_printer(l, c - 1)),
	%                      newline)
	%        ELSE patient_constraint_printer(l, c - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 948, column 1) in decl nil for
	% term generated from patient_constraint_printer
	%  COND c = 0 ->
	%        IF (l(c)`action)`act /= nil_action
	%          THEN concat(concat(concat(concat("rule(", real2str(c)),
	%                                    ") := "),
	%                             rule_type2string(l(c))),
	%                      newline)
	%        ELSE ""
	%        ENDIF,
	%      c > 0 ->
	%        IF (l(c)`action)`act /= nil_action
	%          THEN concat(concat(concat(concat
	%                                    (concat
	%                                     (concat("rule(", real2str(c)),
	%                                      ") := "),
	%                                     rule_type2string(l(c))),
	%                                    space),
	%                             patient_constraint_printer(l, c - 1)),
	%                      newline)
	%        ELSE patient_constraint_printer(l, c - 1)
	%        ENDIF
	% ENDCOND
	% The subtype TCC (at line 977, column 39) in decl nil for
	% term generated from patient_constraint_type2string  climit
	% expected type  cindex
	% The subtype TCC (at line 1012, column 9) in decl nil for
	% term generated from patient_db_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 1013, column 50) in decl nil for
	% term generated from patient_db_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 1016, column 9) in decl nil for
	% term generated from patient_db_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 1017, column 50) in decl nil for
	% term generated from patient_db_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 1017, column 77) in decl nil for
	% term generated from patient_db_printer  p - 1
	% expected type  patient[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 1017, column 55) in decl nil for
	% term generated from patient_db_printer
	%  patient_db_printer(l, p - 1)
	% The disjointness TCC (at line 1010, column 0) in decl nil for
	% term generated from patient_db_printer
	%  COND p = 0 ->
	%        IF l(p)`id /= p_null
	%          THEN concat(concat(concat(concat(newline, "  patient("),
	%                                    real2str(p)),
	%                             ") := "),
	%                      p_state2string(l(p)))
	%        ELSE ""
	%        ENDIF,
	%      p > 0 ->
	%        IF l(p)`id /= p_null
	%          THEN concat(concat(concat(concat
	%                                    (concat(newline, "  patient("),
	%                                     real2str(p)),
	%                                    ") := "),
	%                             p_state2string(l(p))),
	%                      patient_db_printer(l, p - 1))
	%        ELSE patient_db_printer(l, p - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 1010, column 0) in decl nil for
	% term generated from patient_db_printer
	%  COND p = 0 ->
	%        IF l(p)`id /= p_null
	%          THEN concat(concat(concat(concat(newline, "  patient("),
	%                                    real2str(p)),
	%                             ") := "),
	%                      p_state2string(l(p)))
	%        ELSE ""
	%        ENDIF,
	%      p > 0 ->
	%        IF l(p)`id /= p_null
	%          THEN concat(concat(concat(concat
	%                                    (concat(newline, "  patient("),
	%                                     real2str(p)),
	%                                    ") := "),
	%                             p_state2string(l(p))),
	%                      patient_db_printer(l, p - 1))
	%        ELSE patient_db_printer(l, p - 1)
	%        ENDIF
	% ENDCOND
	% The subtype TCC (at line 1025, column 9) in decl nil for
	% term generated from patient_connect_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 1026, column 39) in decl nil for
	% term generated from patient_connect_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 1029, column 9) in decl nil for
	% term generated from patient_connect_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 1030, column 39) in decl nil for
	% term generated from patient_connect_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 1030, column 71) in decl nil for
	% term generated from patient_connect_printer  p - 1
	% expected type  patient[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 1030, column 44) in decl nil for
	% term generated from patient_connect_printer
	%  patient_connect_printer(l, p - 1)
	% The disjointness TCC (at line 1023, column 0) in decl nil for
	% term generated from patient_connect_printer
	%  COND p = 0 ->
	%        IF l(p) /= not_connected
	%          THEN concat(concat(concat(" patient(", real2str(p)),
	%                             ") := "),
	%                      nw_error_type2string(l(p)))
	%        ELSE ""
	%        ENDIF,
	%      p > 0 ->
	%        IF l(p) /= not_connected
	%          THEN concat(concat(concat(concat(" patient(", real2str(p)),
	%                                    ") := "),
	%                             nw_error_type2string(l(p))),
	%                      patient_connect_printer(l, p - 1))
	%        ELSE patient_connect_printer(l, p - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 1023, column 0) in decl nil for
	% term generated from patient_connect_printer
	%  COND p = 0 ->
	%        IF l(p) /= not_connected
	%          THEN concat(concat(concat(" patient(", real2str(p)),
	%                             ") := "),
	%                      nw_error_type2string(l(p)))
	%        ELSE ""
	%        ENDIF,
	%      p > 0 ->
	%        IF l(p) /= not_connected
	%          THEN concat(concat(concat(concat(" patient(", real2str(p)),
	%                                    ") := "),
	%                             nw_error_type2string(l(p))),
	%                      patient_connect_printer(l, p - 1))
	%        ELSE patient_connect_printer(l, p - 1)
	%        ENDIF
	% ENDCOND
	% The subtype TCC (at line 1038, column 11) in decl nil for
	% term generated from device_connect_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 1039, column 40) in decl nil for
	% term generated from device_connect_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 1042, column 11) in decl nil for
	% term generated from device_connect_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 1043, column 40) in decl nil for
	% term generated from device_connect_printer  d
	% expected type  upto(dlimit)
	% The subtype TCC (at line 1043, column 71) in decl nil for
	% term generated from device_connect_printer  d - 1
	% expected type  device[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 1043, column 45) in decl nil for
	% term generated from device_connect_printer
	%  device_connect_printer(l, d - 1)
	% The disjointness TCC (at line 1036, column 2) in decl nil for
	% term generated from device_connect_printer
	%  COND d = 0 ->
	%        IF l(d) /= not_connected
	%          THEN concat(concat(concat(" device(", real2str(d)),
	%                             ") := "),
	%                      nw_error_type2string(l(d)))
	%        ELSE ""
	%        ENDIF,
	%      d > 0 ->
	%        IF l(d) /= not_connected
	%          THEN concat(concat(concat(concat(" device(", real2str(d)),
	%                                    ") := "),
	%                             nw_error_type2string(l(d))),
	%                      device_connect_printer(l, d - 1))
	%        ELSE device_connect_printer(l, d - 1)
	%        ENDIF
	% ENDCOND
	% The coverage TCC (at line 1036, column 2) in decl nil for
	% term generated from device_connect_printer
	%  COND d = 0 ->
	%        IF l(d) /= not_connected
	%          THEN concat(concat(concat(" device(", real2str(d)),
	%                             ") := "),
	%                      nw_error_type2string(l(d)))
	%        ELSE ""
	%        ENDIF,
	%      d > 0 ->
	%        IF l(d) /= not_connected
	%          THEN concat(concat(concat(concat(" device(", real2str(d)),
	%                                    ") := "),
	%                             nw_error_type2string(l(d))),
	%                      device_connect_printer(l, d - 1))
	%        ELSE device_connect_printer(l, d - 1)
	%        ENDIF
	% ENDCOND
	% The subtype TCC (at line 1049, column 30) in decl nil for
	% term generated from device_connect_type2string  dc
	% expected type  [upto(dlimit) ->
	%    nw_error_type[maxrate, maxinfuse, maxtime]]
	% The subtype TCC (at line 1049, column 34) in decl nil for
	% term generated from device_connect_type2string  dlimit
	% expected type  device[maxrate, maxinfuse, maxtime]
	% The subtype TCC (at line 1054, column 45) in decl nil for
	% term generated from patient_device_connect_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 1055, column 45) in decl nil for
	% term generated from patient_device_connect_printer  p
	% expected type  upto(plimit)
	% The subtype TCC (at line 1055, column 84) in decl nil for
	% term generated from patient_device_connect_printer  p - 1
	% expected type  patient[maxrate, maxinfuse, maxtime]
	% The termination TCC (at line 1055, column 50) in decl nil for
	% term generated from patient_device_connect_printer
	%  patient_device_connect_printer(l, p - 1)
	% The disjointness TCC (at line 1053, column 0) in decl nil for
	% term generated from patient_device_connect_printer
	%  COND p = 0 ->
	%        concat(concat(concat(" patient(", real2str(p)), ") := "),
	%               device_connect_type2string(l(p))),
	%      p > 0 ->
	%        concat(concat(concat(concat(" patient(", real2str(p)),
	%                             ") := "),
	%                      device_connect_type2string(l(p))),
	%               patient_device_connect_printer(l, p - 1))
	% ENDCOND
	% The coverage TCC (at line 1053, column 0) in decl nil for
	% term generated from patient_device_connect_printer
	%  COND p = 0 ->
	%        concat(concat(concat(" patient(", real2str(p)), ") := "),
	%               device_connect_type2string(l(p))),
	%      p > 0 ->
	%        concat(concat(concat(concat(" patient(", real2str(p)),
	%                             ") := "),
	%                      device_connect_type2string(l(p))),
	%               patient_device_connect_printer(l, p - 1))
	% ENDCOND
	% The subtype TCC (at line 1061, column 31) in decl nil for
	% term generated from node_to_patient2string  np
	% expected type  [upto(nlimit) -> patient[maxrate, maxinfuse, maxtime]]
	% The subtype TCC (at line 1061, column 35) in decl nil for
	% term generated from node_to_patient2string  nlimit
	% expected type  node[maxrate, maxinfuse, maxtime]
	% The subtype TCC (at line 1065, column 26) in decl nil for
	% term generated from node_to_pd2string  nd
	% expected type  [upto(nlimit) ->
	%    patient_to_device[maxrate, maxinfuse, maxtime]]
	% The subtype TCC (at line 1065, column 30) in decl nil for
	% term generated from node_to_pd2string  nlimit
	% expected type  node[maxrate, maxinfuse, maxtime]
	% The subtype TCC (at line 1093, column 30) in decl nil for
	% term generated from patient_connect_type2string  pc
	% expected type  [upto(plimit) ->
	%    nw_error_type[maxrate, maxinfuse, maxtime]]
	% The subtype TCC (at line 1093, column 34) in decl nil for
	% term generated from patient_connect_type2string  plimit
	% expected type  patient[maxrate, maxinfuse, maxtime]
	% Subtype TCC generated (at line 1097, column 41) for  last_patient
	% expected type  patient[maxrate, maxinfuse, maxtime]
	  % proved
	patient_device_connect_type2string_TCC1: OBLIGATION
	last_patient <= nlimit
	
	% The subtype TCC (at line 977, column 39) in decl nil for
	 % term generated from patient_constraint_type2string  climit
	    % expected type  cindex
	  % is subsumed by production_type2string_TCC1
	% The subtype TCC (at line 1012, column 9) in decl nil for
	 % term generated from patient_db_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC1
	% The subtype TCC (at line 1013, column 50) in decl nil for
	 % term generated from patient_db_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC1
	% The subtype TCC (at line 1016, column 9) in decl nil for
	 % term generated from patient_db_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC2
	% The subtype TCC (at line 1017, column 50) in decl nil for
	 % term generated from patient_db_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC2
	% The subtype TCC (at line 1017, column 77) in decl nil for
	 % term generated from patient_db_printer  p - 1
	    % expected type  patient[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 1017, column 55) in decl nil for
	 % term generated from patient_db_printer
	    %  patient_db_printer(l, p - 1)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 1010, column 0) in decl nil for
	 % term generated from patient_db_printer
	    %  COND p = 0 ->
	    %        IF l(p)`id /= p_null
	    %          THEN concat(concat(concat(concat(newline, "  patient("),
	    %                                    real2str(p)),
	    %                             ") := "),
	    %                      p_state2string(l(p)))
	    %        ELSE ""
	    %        ENDIF,
	    %      p > 0 ->
	    %        IF l(p)`id /= p_null
	    %          THEN concat(concat(concat(concat
	    %                                    (concat(newline, "  patient("),
	    %                                     real2str(p)),
	    %                                    ") := "),
	    %                             p_state2string(l(p))),
	    %                      patient_db_printer(l, p - 1))
	    %        ELSE patient_db_printer(l, p - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 1010, column 0) in decl nil for
	 % term generated from patient_db_printer
	    %  COND p = 0 ->
	    %        IF l(p)`id /= p_null
	    %          THEN concat(concat(concat(concat(newline, "  patient("),
	    %                                    real2str(p)),
	    %                             ") := "),
	    %                      p_state2string(l(p)))
	    %        ELSE ""
	    %        ENDIF,
	    %      p > 0 ->
	    %        IF l(p)`id /= p_null
	    %          THEN concat(concat(concat(concat
	    %                                    (concat(newline, "  patient("),
	    %                                     real2str(p)),
	    %                                    ") := "),
	    %                             p_state2string(l(p))),
	    %                      patient_db_printer(l, p - 1))
	    %        ELSE patient_db_printer(l, p - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	% The subtype TCC (at line 1025, column 9) in decl nil for
	 % term generated from patient_connect_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC1
	% The subtype TCC (at line 1026, column 39) in decl nil for
	 % term generated from patient_connect_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC1
	% The subtype TCC (at line 1029, column 9) in decl nil for
	 % term generated from patient_connect_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC2
	% The subtype TCC (at line 1030, column 39) in decl nil for
	 % term generated from patient_connect_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC2
	% The subtype TCC (at line 1030, column 71) in decl nil for
	 % term generated from patient_connect_printer  p - 1
	    % expected type  patient[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 1030, column 44) in decl nil for
	 % term generated from patient_connect_printer
	    %  patient_connect_printer(l, p - 1)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 1023, column 0) in decl nil for
	 % term generated from patient_connect_printer
	    %  COND p = 0 ->
	    %        IF l(p) /= not_connected
	    %          THEN concat(concat(concat(" patient(", real2str(p)),
	    %                             ") := "),
	    %                      nw_error_type2string(l(p)))
	    %        ELSE ""
	    %        ENDIF,
	    %      p > 0 ->
	    %        IF l(p) /= not_connected
	    %          THEN concat(concat(concat(concat(" patient(", real2str(p)),
	    %                                    ") := "),
	    %                             nw_error_type2string(l(p))),
	    %                      patient_connect_printer(l, p - 1))
	    %        ELSE patient_connect_printer(l, p - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 1023, column 0) in decl nil for
	 % term generated from patient_connect_printer
	    %  COND p = 0 ->
	    %        IF l(p) /= not_connected
	    %          THEN concat(concat(concat(" patient(", real2str(p)),
	    %                             ") := "),
	    %                      nw_error_type2string(l(p)))
	    %        ELSE ""
	    %        ENDIF,
	    %      p > 0 ->
	    %        IF l(p) /= not_connected
	    %          THEN concat(concat(concat(concat(" patient(", real2str(p)),
	    %                                    ") := "),
	    %                             nw_error_type2string(l(p))),
	    %                      patient_connect_printer(l, p - 1))
	    %        ELSE patient_connect_printer(l, p - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	% The subtype TCC (at line 1038, column 11) in decl nil for
	 % term generated from device_connect_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC1
	% The subtype TCC (at line 1039, column 40) in decl nil for
	 % term generated from device_connect_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC1
	% The subtype TCC (at line 1042, column 11) in decl nil for
	 % term generated from device_connect_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC2
	% The subtype TCC (at line 1043, column 40) in decl nil for
	 % term generated from device_connect_printer  d
	    % expected type  upto(dlimit)
	  % is subsumed by device_printer_bool_TCC2
	% The subtype TCC (at line 1043, column 71) in decl nil for
	 % term generated from device_connect_printer  d - 1
	    % expected type  device[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 1043, column 45) in decl nil for
	 % term generated from device_connect_printer
	    %  device_connect_printer(l, d - 1)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 1036, column 2) in decl nil for
	 % term generated from device_connect_printer
	    %  COND d = 0 ->
	    %        IF l(d) /= not_connected
	    %          THEN concat(concat(concat(" device(", real2str(d)),
	    %                             ") := "),
	    %                      nw_error_type2string(l(d)))
	    %        ELSE ""
	    %        ENDIF,
	    %      d > 0 ->
	    %        IF l(d) /= not_connected
	    %          THEN concat(concat(concat(concat(" device(", real2str(d)),
	    %                                    ") := "),
	    %                             nw_error_type2string(l(d))),
	    %                      device_connect_printer(l, d - 1))
	    %        ELSE device_connect_printer(l, d - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 1036, column 2) in decl nil for
	 % term generated from device_connect_printer
	    %  COND d = 0 ->
	    %        IF l(d) /= not_connected
	    %          THEN concat(concat(concat(" device(", real2str(d)),
	    %                             ") := "),
	    %                      nw_error_type2string(l(d)))
	    %        ELSE ""
	    %        ENDIF,
	    %      d > 0 ->
	    %        IF l(d) /= not_connected
	    %          THEN concat(concat(concat(concat(" device(", real2str(d)),
	    %                                    ") := "),
	    %                             nw_error_type2string(l(d))),
	    %                      device_connect_printer(l, d - 1))
	    %        ELSE device_connect_printer(l, d - 1)
	    %        ENDIF
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	% The subtype TCC (at line 1049, column 30) in decl nil for
	 % term generated from device_connect_type2string  dc
	    % expected type  [upto(dlimit) ->
	                   %    nw_error_type[maxrate, maxinfuse, maxtime]]
	  % is subsumed by main_enum_par2string_TCC1
	% The subtype TCC (at line 1049, column 34) in decl nil for
	 % term generated from device_connect_type2string  dlimit
	    % expected type  device[maxrate, maxinfuse, maxtime]
	  % is subsumed by devices2string_TCC2
	% The subtype TCC (at line 1054, column 45) in decl nil for
	 % term generated from patient_device_connect_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC1
	% The subtype TCC (at line 1055, column 45) in decl nil for
	 % term generated from patient_device_connect_printer  p
	    % expected type  upto(plimit)
	  % is subsumed by patient_printer_bool_TCC2
	% The subtype TCC (at line 1055, column 84) in decl nil for
	 % term generated from patient_device_connect_printer  p - 1
	    % expected type  patient[maxrate, maxinfuse, maxtime]
	  % is subsumed by nodes_link_printer_TCC1
	% The termination TCC (at line 1055, column 50) in decl nil for
	 % term generated from patient_device_connect_printer
	    %  patient_device_connect_printer(l, p - 1)
	  % is subsumed by nodes_link_printer_TCC2
	% The disjointness TCC (at line 1053, column 0) in decl nil for
	 % term generated from patient_device_connect_printer
	    %  COND p = 0 ->
	    %        concat(concat(concat(" patient(", real2str(p)), ") := "),
	    %               device_connect_type2string(l(p))),
	    %      p > 0 ->
	    %        concat(concat(concat(concat(" patient(", real2str(p)),
	    %                             ") := "),
	    %                      device_connect_type2string(l(p))),
	    %               patient_device_connect_printer(l, p - 1))
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC5
	% The coverage TCC (at line 1053, column 0) in decl nil for
	 % term generated from patient_device_connect_printer
	    %  COND p = 0 ->
	    %        concat(concat(concat(" patient(", real2str(p)), ") := "),
	    %               device_connect_type2string(l(p))),
	    %      p > 0 ->
	    %        concat(concat(concat(concat(" patient(", real2str(p)),
	    %                             ") := "),
	    %                      device_connect_type2string(l(p))),
	    %               patient_device_connect_printer(l, p - 1))
	    % ENDCOND
	  % is subsumed by node_printer_bool_TCC6
	% The subtype TCC (at line 1061, column 31) in decl nil for
	 % term generated from node_to_patient2string  np
	    % expected type  [upto(nlimit) -> patient[maxrate, maxinfuse, maxtime]]
	  % is subsumed by connected2string_TCC1
	% The subtype TCC (at line 1061, column 35) in decl nil for
	 % term generated from node_to_patient2string  nlimit
	    % expected type  node[maxrate, maxinfuse, maxtime]
	  % is subsumed by connected2string_TCC2
	% The subtype TCC (at line 1065, column 26) in decl nil for
	 % term generated from node_to_pd2string  nd
	    % expected type  [upto(nlimit) ->
	                   %    patient_to_device[maxrate, maxinfuse, maxtime]]
	  % is subsumed by connected2string_TCC1
	% The subtype TCC (at line 1065, column 30) in decl nil for
	 % term generated from node_to_pd2string  nlimit
	    % expected type  node[maxrate, maxinfuse, maxtime]
	  % is subsumed by connected2string_TCC2
	% The subtype TCC (at line 1093, column 30) in decl nil for
	 % term generated from patient_connect_type2string  pc
	    % expected type  [upto(plimit) ->
	                   %    nw_error_type[maxrate, maxinfuse, maxtime]]
	  % is subsumed by action_error_type2string_TCC1
	% The subtype TCC (at line 1093, column 34) in decl nil for
	 % term generated from patient_connect_type2string  plimit
	    % expected type  patient[maxrate, maxinfuse, maxtime]
	  % is subsumed by patients_type2string_TCC2
	
	% The subtype TCC (at line 1097, column 37) in decl nil for
	 % term generated from patient_device_connect_type2string  pc
	    % expected type  [upto(plimit) ->
	                   %    device_connect_type[maxrate, maxinfuse, maxtime]]
	  % is subsumed by action_error_type2string_TCC1
	% The subtype TCC (at line 1135, column 25) in decl nil for
	 % term generated from patient_db_type2string  pd
	    % expected type  [upto(plimit) -> p_state[maxrate, maxinfuse, maxtime]]
	  % is subsumed by action_error_type2string_TCC1

END printer_TCCS